<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title>PowerPoint-Präsentation</title>
  <meta name="generator" content="LibreOffice 25.2.3.2 (Linux)"/>
  <meta name="author" content="Daniel Hauer"/>
  <meta name="created" content="2023-04-28T07:59:46"/>
  <meta name="changedby" content="Daniel Hauer"/>
  <meta name="changed" content="2025-10-26T09:05:25"/>
  <meta name="AppVersion" content="16.0000"/>
  <meta name="HiddenSlides" content="2"/>
  <meta name="Notes" content="60"/>
  <meta name="PresentationFormat" content="Breitbild"/>
  <meta name="Slides" content="65"/>
</head>
<body>
<h1><b>XTS TRANSPORT LAYER – a station based approach</b></h1>
<h1 style="page-break-before:always; "><b>XTS TRANSPORT LAYER	
                                           Daniel Hauer (HAUD)</b></h1>
<ul>
<li>Introduction</li>
<li>Requirements</li>
<ul>
<li>XtsTransport (main control)</li>
<li>Xpu (XTS Processing Unit)</li>
<li>CaGroup (Collision Avoidance)</li>
<li>Mover (MC and CA)</li>
<li>Station (process handshake)</li>
</ul>
<li>Design</li>
<ul>
<li>use with any cyclic runtime</li>
<li>use with non cyclic software</li>
</ul>
<li>Examples</li>
<li>License</li>
</ul>
<h1 style="page-break-before:always; "><b>XTS TRANSPORT LAYER	(HAUD)</b></h1>
<h2>1. Introduction</h2>
<ul>
<ul>
<li>This project collection is intended to convey the idea of a stand alone XTS transport layer to use in heterogeneous environments / applications.
</li>
<li>One main idea is that for every process you require, a corresponding position on the XTS exists.</li>
<ul>
<li>The station</li>
</ul>
<li>Another fundamental principle is that before anybody does anything, they must know what to do and  that everybody involved in transport gets a list with atomic RW access.
</li>
<ul>
<li>The <b>sending</b> of movers runs parallel to <b>sending</b> information</li>
<ul>
<li>This rids us from stations needing to talk to each other
</li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>XTS TRANSPORT LAYER	(HAUD)</b></h1>
<h2>1. Introduction</h2>
<ul>
<ul>
<li>A transport layer shall a data driven way to manipulate a stations behaviour
</li>
<li>A transport layer shall work a combination of discrete processes and continuous processes
</li>
<li>A transport layer shall have an interface for guiding a mover through a process station
</li>
<li>A transport layer shall have an interface to manipulate a mover
</li>
<li>A transport layer shall have an interface for setting-up or clearing the CollisionAvoidance Group
</li>
<li>A transport layer shall provide higher level layers for grouping of stations and coding of transport logic</li>
<li>A transport layer shall enable use of all, or some layers provided.</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>XTS TRANSPORT LAYER	(HAUD)</b></h1>
<h2>1. Introduction</h2>
<ul>
<ul>
<li>In combination with the Collision Avoidance library sending movers does not require extra monitoring of the movement. The Collision Avoidance Group is controlling the gap between movers. The gap is an input parameter of the CA motion function blocks.
</li>
<li>Can be used for a station based approach, in which a station class is available for interaction with your process control.
</li>
<li>Can be used for a mover based approach, your process control has a direct connection to every mover.
</li>
<li>Can be used as a combination of station based and mover based approach.
</li>
<li>The use of predefined datafields also enables control of XTS TRANSPORT LAYER via fieldbus or network.
</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>XTS TRANSPORT LAYER	(HAUD)</b></h1>
<h2>1. Introduction</h2>
<ul>
<ul>
<li>The XTS transport system enables a flexible product transport for various use cases. This transport layer deliberately tackles a specific subset of the flexibility of the XTS system.
</li>
<li>This subset is working on:</li>
<ul>
<li>One closed loop</li>
<li>One Track</li>
<li>Constant Mover count
</li>
</ul>
<li>As all movers bound to the same rail:</li>
<ul>
<li>No passing at all times</li>
<li>A station table seems like a good choice
</li>
</ul>
<li>This transport layer will focus on enabling high throughput and high flexibility process flow</li>
<ul>
<li>Layered approach to offer you granular BlackBox building.</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>XTS TRANSPORT LAYER	(HAUD)</b></h1>
<h2>1. Introduction</h2>
<ul>
<ul>
<li>designed for use with extern cyclic or non-cyclic flow control (PLC, EtherCAT, <b>any</b> network)</li>
<ul>
<li>Ctrl / State datafields for extern to access</li>
</ul>
<li>station based approach and individual manipulation of mover</li>
<li>handshake in station with extern process flow (ST_STATION_CTRL / ST_STATION_STATE)</li>
<li>individual cyclic mover interface with given set of movement functionalities (ST_MOVER_CTRL / ST_MOVER_STATE)</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>2. Requirements</b></h1>
<ul>
<li>TransportUnit</li>
<ul>
<li>Access to CA group function blocks (interface pointer)
</li>
<li>Access to Stations (interface pointer)</li>
<li>Access to Movers (interface pointer)
</li>
<li>Commands for getting all members to defined state</li>
<li>Cyclic interface for access from extern control</li>
<ul>
<li>Ctrl (write): command</li>
<li>State (read): response to command</li>
<ul>
<li>information from Xpu</li>
<li>Information from CA Group</li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>2. Requirements</b></h1>
<ul>
<li>Xpu (XTS Processing Unit)</li>
<ul>
<li>Check Init Parameter</li>
<li>Check Online Parameter</li>
<li>Get Module Info Data</li>
<li>Connect TcCOM Objects to instances from XTS_Utility.lib function blocks</li>
<li>Cyclic plausibility checks</li>
<ul>
<li>Mover ID detection after init</li>
</ul>
<li>Cyclic interface for access from main control</li>
<ul>
<li>Ctrl (write): command</li>
<li>State (read): response to command</li>
<li>Info (read): details from cyclic checks</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>2. Requirements</b></h1>
<ul>
<li>CaGroup</li>
<ul>
<li>Access to group function blocks</li>
<li>Access to movers for group commands</li>
<li>Get Group Info Data</li>
<li>Implements interface for use in</li>
<ul>
<li>TransportUnit</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>2. Requirements</b></h1>
<ul>
<li>Mover</li>
<ul>
<li>Access to MC function blocks
</li>
<li>Access to CA function blocks
</li>
<li>Cyclic interface for access from extern control</li>
<ul>
<li>Ctrl (write): command</li>
<li>Data (write): command parameter</li>
<li>State (read): response to command</li>
</ul>
<li>Implements Interface pointer for access from:</li>
<ul>
<li>TransportUnit</li>
<li>Station</li>
<li>CaGroup</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>2. Requirements</b></h1>
<ul>
<li>Station</li>
<ul>
<li>Handshake mover transport with extern control
</li>
<li>Close observation of movements in station with feedback to extern control</li>
<li>Linked List for movers in queue for infeed into station
</li>
<li>Access to Linked List of target station for outfeed of mover
</li>
<li>Cyclic interface for access from extern control</li>
<ul>
<li>Ctrl (write): command and parameter</li>
<li>State (read): response to command and information about mover and queue</li>
</ul>
<li>requires interface pointer to MC functionblocks</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>Namespace GVL_XTS</li>
<ul>
<li><b>Station</b></li>
<ul>
<li>Handshake with  Process
for mover transport</li>
</ul>
<li><b>XtsTransport</b></li>
<ul>
<li>Main command interface to 
extern control</li>
</ul>
<li><b>Xpu</b></li>
<ul>
<li>Access to TcCOM Objects</li>
<li>Cyclic plausibility checks</li>
</ul>
<li><b>CaGroup</b></li>
<ul>
<li>Access to CA library</li>
</ul>
<li><b>Mover</b></li>
<ul>
<li>Access to MC and CA library</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li><b>Yes, …but why?</b></li>
<ul>
<li>The ‚WHYs‘ for the station explains the rest of the design</li>
<ul>
<li>I focus on stations first since they are the center of attention when production runs</li>
</ul>
<li>The goal is to build maintainability into the transport layer
(e.g. in case MC3 becomes available in the stable feed of the package manager)</li>
<li>This transport layer is intended to be flexible in complexity and application</li>
<ul>
<li>This is why you‘ll discover ABSTRACT classes
</li>
</ul>
<li>OOP (… Yeah you know me!) <b>it makes things so much easier.</b> </li>
<ul>
<li>Please try to overcome the reflex of it ‚being too much‘ for PLC programming </li>
<li>it is not 1993 anymore, OOP is around for 20 years now.</li>
<li>It is the reason this collection of projects is so easy.
</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>Yes, …but why?</li>
</ul>
<table>
  <tr>
    <td>
<p><b>Fb / Class</b></p>
    </td>
    <td>
<p><b>Concern</b></p>
    </td>
    <td>
<p><b>Solution</b></p>
    </td>
  </tr>
  <tr>
    <td>
<p>Station</p>
    </td>
    <td>
<p>Manipulation of one mover</p>
    </td>
    <td>
<p><b>I_Transport_Mover[nMoverDetected]</b></p>
    </td>
  </tr>
  <tr>
    <td>
    </td>
    <td>
<p>Handshake process-flow with external entity</p>
    </td>
    <td>
<p>Ctrl / State pair</p>
    </td>
  </tr>
  <tr>
    <td>
    </td>
    <td>
<p>Where does the mover come from?</p>
<p>Who cares, I‘ll just take the first</p>
    </td>
    <td>
<p>Use of Interface of LinkedList and struct datafields for tickets: <b>I_Station_LinkedList</b></p>
    </td>
  </tr>
  <tr>
    <td>
    </td>
    <td>
<p>Access to ST_STATION_PARAMETER of all stations</p>
    </td>
    <td>
<p>Pointer/Reference to table of stations</p>
    </td>
  </tr>
  <tr>
    <td>
    </td>
    <td>
<p>Who am I?</p>
    </td>
    <td>
<p>MAIN injects loop counter:</p>
<p>GVL_XTS.Station[nStation].<b>StationId</b>   := nStation;</p>
    </td>
  </tr>
  <tr>
    <td>
    </td>
    <td>
<p>Where am I?</p>
    </td>
    <td>
<p>ST_STATION_PARAMETER[StationId]</p>
    </td>
  </tr>
  <tr>
    <td>
    </td>
    <td>
<p>Where am I precisely?</p>
    </td>
    <td>
<p>Pointer to static offset datafields[MAX_STATION, MAX_MOVER, MAX_NESTS]</p>
    </td>
  </tr>
</table>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>Namespace XTS_Parameter</li>
<ul>
<li>Project constants must match configuration:</li>
<li>Copied from ParameterList in: Tc3_XTS_Utility.TcIoXtsEnvironmentParameterList</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station</li>
<ul>
<li><b>fb_StationBase</b></li>
<ul>
<li>Abstract base class</li>
<li>Allowing for user defined XtsStations</li>
<li>Provides datafields and properties</li>
<li>Cycle placeholder; override with your station logic when extending this base class</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station
</li>
<ul>
<li>fb_StationProcess[].Cycle</li>
<ul>
<li>State machine for handshaking 
with extern control (check example pdf in [doc] folder)</li>
<ul>
<li>Init (clears everything in station)</li>
<li>Enable</li>
<li>Mover Enter</li>
<li>Stop Position(s)</li>
<li>Mover Out</li>
<li>Empty</li>
</ul>
</ul>
</ul>
</ul>
<ul>
<li>GVL_XTS.Station
</li>
<ul>
<li>fb_StationProcess[].Cycle</li>
<ul>
<li>Control writes ticket for mover</li>
<ul>
<li>MoverId </li>
<li>TargetStation</li>
<li>Mask</li>
<li>Offset</li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station</li>
<ul>
<li>nStation index is passed as value from caller</li>
<li>Global datafields are passed as references (REF=) into fb_StationBase properties</li>
<ul>
<li>Ctrl / State: handshakes</li>
<li>ItfStations: interface pointer to linked list methods for getting and setting of mover data</li>
<li>StationParameter: Coordinates and dynamic constraint of XtsStation</li>
<li>MoverOffset: correction values for every mover in every station with every nest (PosStop[])</li>
<li>ItfMover: interface pointer to CA movements</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li><b>GVL_XTS.Station 
- Planning requirements for use of fb_StationProcess
</b></li>
<ul>
<ul>
<li><b>One station: one mover</b></li>
<ul>
<li>If you require multiple movers for your process:</li>
<ul>
<li>parallel  multiplication of the same task:</li>
<ul>
<ul>
<li> fb_StationCollector and fb_ProcessCollector will help 
grouping the stations to a single Ctrl/State interface. 
(see example <b>XTS_DEMO_APPLICATION_108</b>)
</li>
</ul>
</ul>
</ul>
</ul>
<li><b>Station to Station: only forward</b></li>
<ul>
<li>We‘re on a closed loop (the defining part of the subset my focus lies on)
</li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li><b>GVL_XTS.Station 
- Planning requirements for use of fb_StationProcess
</b></li>
<ul>
<ul>
<li>Put the Modulo turn anywhere, <b>BUT NOT </b>within PosWait, PosStop, ReleaseDistance of a station. 
The code does not support crossing the modulo turn within a station.
</li>
<li>Since the project is designed for stations to send movers to a flexible target, with flexible nest positions, the control struct of a station you have to use, to forward those parameters. The MoverId is forwarded by the Station in possession of the mover.
</li>
<ul>
<li><b>ST_STATION_CTRL.nMask: </b>commands the nest count and nest position of the mover in target station 
</li>
<li><b>ST_STATION_CTRL.nTargetStation: </b>index of station in GVL_XTS.StationParameter[]
</li>
<li><b>ST_STATION_CTRL.rOffset:</b> optional dynamic inline offset (added to every nest)</li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li><b>GVL_XTS.Station 
- Planning requirements for use of
  fb_StationProcess
</b></li>
<ul>
<ul>
<li>The Use of <b>LinkedList</b> methods (AddTail, GetHead) 
<b>requires thought </b>about <b>when</b> the mover is entered into the target station. </li>
<ul>
<li> why?  The targets’ list must stay sorted  see examples on next pages
</li>
<li>fb_StationProcess.Cycle() is built in a way (see handshake flowcharts for this) that the movers’ ticket is written via the list interface of the target station <b>after</b> having moved <b>rReleaseDistance</b> (a station parameter):</li>
<h2><b></b></h2>
<ul>
<li><b>The movement:</b></li>
</ul>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li><b>GVL_XTS.Station 
- Planning requirements for use of
  fb_StationProcess
</b></li>
<ul>
<ul>
<li>The Use of <b>LinkedList</b> methods (AddTail, GetHead) 
<b>requires thought </b>about <b>when</b> the mover is entered into the target station. </li>
<ul>
<li> why?  The targets’ list must stay sorted  see examples on next pages
</li>
<li>fb_StationProcess.Cycle() is built in a way (see handshake flowcharts for this) that the movers’ <b>ticket is written</b> via the list <b>interface</b> of the target station after having moved rReleaseDistance (a station parameter):</li>
<h2><b></b></h2>
<ul>
<li><b>The ticket:</b></li>
</ul>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li><b>GVL_XTS.Station - Planning requirements for use of fb_StationProcess
</b></li>
<ul>
<ul>
<li>all coordinates are modulo values, </li>
<ul>
<li>from station to station only forward</li>
<li>within station: movement by use of nest offset(PosStop[]) or use of <b>ST_MOVER_CTRL</b>.</li>
<li>Within station: all kind of MC functions

</li>
</ul>
<li><b>IF</b> move backwards is required you have to make sure that there is room for it by setting ST_STATION_PARAMETER so the movement of the movers match your process requirements for each station</li>
<ul>
<li>Check PosStop[]</li>
<li>Each PosStop[] is <b>relative</b> to PosWait</li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station (Example)
</li>
<li><b>ST_STATION_PARAMETER</b>: parallel Xts stations for a process with common waiting position
</li>
<ul>
<li>Process uses GVL_XTS.Station[1] to GVL_XTS.Station[4]</li>
<ul>
<li>Define PosWait(Queue position)</li>
<ul>
<li><b>[1].rPosWait := 100</b></li>
<li><b>[2].rPosWait := 100</b></li>
<li><b>[3].rPosWait := 100</b></li>
<li><b>[4].rPosWait := 100</b></li>
</ul>
<li>Define how many rPosStop(nests) the stations may have (configured count)		</li>
<ul>
<li><b>[1].nConfiguredStopCount := 1 (default)</b></li>
<li><b>[2].nConfiguredStopCount := 1</b></li>
<li><b>[3].nConfiguredStopCount := 1</b></li>
<li><b>[4].nConfiguredStopCount := 1</b></li>
</ul>
</ul>
</ul>
</ul>
<p>
</p>
<p>

</p>
<ul>
<ul>
<li>Process uses GVL_XTS.Station[1] to GVL_XTS.Station[4]</li>
<ul>
<li>Define the process position(s) relative to rPosWait</li>
<ul>
<li><b>[1].rPosStop[1] := 100</b></li>
<li><b>[2].rPosStop[1] := 200</b></li>
<li><b>[3].rPosStop[1] := 300</b></li>
<li><b>[4].rPosStop[1] := 400</b>
</li>
</ul>
<li>The ReleaseDistance of <b>the last station shall be shortest</b>, all other stations follow accordingly.</li>
<ul>
<li><b>[1].rReleaseDistance := 40</b></li>
<li><b>[2].rReleaseDistance := 30</b></li>
<li><b>[3].rReleaseDistance := 20</b></li>
<li><b>[4].rReleaseDistance := 10</b></li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station (Example)
</li>
<li><b>What it may look like</b>: parallel Xts stations for a process with common waiting position </li>
<ul>
<li>drawings are not to scale, the possible configurations shall be illustrated</li>
<li><b>Ex04</b>: 
This configuration is useful if you require the working area to be completely empty before pulling in movers. (move something other than your directly involved process mechanics out of the way of the mover etc.)
</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station (Example)
</li>
<li><b>What it may look like</b>: parallel Xts stations for a process with common waiting position </li>
<ul>
<li>drawings are not to scale, the possible configurations shall be illustrated</li>
<li><b>Ex05</b>: 
This configuration is useful if you require high throughput with minimal stops of the mover. rPosWait[1-4] are already commanded by the sending station.
</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station (Example)
</li>
<li><b>What it may look like</b>: parallel Xts stations for a process with common waiting position </li>
<ul>
<li>drawings are not to scale, the possible configurations shall be illustrated</li>
<li><b>Ex06</b>: 
This configuration is useful if you require high throughput and <b>irregular spacing</b> with minimal stops of the mover. rPosWait[1-4] are already commanded by the sending station.
</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station (Example)
</li>
<li><b>using stations sparsely</b>:</li>
<ul>
<li>In this case it is easiest to always handshake the stations and use the forwarding command if a station shall be skipped.</li>
<li>On Infeed state of mover, use: <b>E_STATION_CTRL. STATION_MOVER_SEND</b>.</li>
<ul>
<li>There are different handshake ‘routes’  see pdfs <b>GVL_XTS.Station_Example_*.pdf</b>
</li>
</ul>
</ul>
<li><b>deactivating stations</b>:</li>
<ul>
<li>Make sure the queue is empty before deactivating, since the waiting mover will hold up all other,
in case of required deactivation while movers are in the queue:</li>
<ul>
<li>handshake mover with <b>E_STATION_CTRL.STATION_MOVER_SEND</b> 
to new target station if mover in queue cannot be processed
</li>
<li>Handshake regular infeed if mover in queue can still be processed.
</li>
<li>Do not send any new mover to the station in question</li>
<ul>
<li>If queue of station is empty: <b>E_STATION_CTRL.STATION_DISABLE</b></li>
<li>preceding stations continue workflow with changed <b>ST_STATION_CTRL.nTargetStation</b></li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station
</li>
<ul>
<li>Ctrl[nStation] : <b>ST_STATION_CTRL</b></li>
<ul>
<li><b>eCmd (E_STATION_CTRL):</b> </li>
<ul>
<li>enumeration for handshakes with State[nStation].eState <b>(E_STATION_STATE)
</b></li>
</ul>
<li><b>nMask (BYTE):</b> </li>
<ul>
<li>bit mask to be used with multiple stop positions within a XtsStation.
This mask tells the target station which PosStop[] (nest) has to be worked.
</li>
</ul>
<li><b>nTargetStation (USINT):</b> </li>
<ul>
<li>target to send mover to  GVL_XTS.Station[nTargetStation].rPosWait
</li>
</ul>
<li><b>rOffset (REAL):</b> </li>
<ul>
<li>Optional offset for mover, used in target station in addition to static offset</li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Station
</li>
<ul>
<li>State[nStation] : <b>ST_STATION_STATE</b></li>
<ul>
<li><b>eState (E_STATION_STATE): </b></li>
<ul>
<li>Enumeration for active station state, Ctrl has to react to 
</li>
</ul>
<li><b>nMask (BYTE): </b></li>
<ul>
<li>Bitmask for active PosStop[] (nest)
</li>
</ul>
<li><b>nMoverId (USINT):</b></li>
<ul>
<li>Active mover index in station
</li>
</ul>
<li><b>rMoverModPos (LREAL): </b></li>
<ul>
<li>Modulo position of active mover
</li>
</ul>
<li><b>nQueue (USINT):</b></li>
<ul>
<li>Count of movers, which were sent to XtsStation</li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.StationParameter
</li>
<ul>
<li><b>eType</b>:</li>
<ul>
<li> STATION_PROCESS,	// default station with/without process</li>
<li> STATION_GEAR_IN_POS	// GearInPos station for flying saw with MasterAxis</li>
</ul>
<li><b>sText :</b></li>
<ul>
<li>Description only</li>
</ul>
<li><b>rPosWait :</b></li>
<ul>
<li>start of station, a sending station is using this value to send mover to</li>
</ul>
<li><b>rReleaseDistance :</b></li>
<ul>
<li>distance mover has to travel (from ActPos) in order for station to go back to mover detection</li>
</ul>
<li><b>rGap :</b></li>
<ul>
<li>Active gap on infeed and outfeed of station</li>
</ul>
<li><b>rVelo :</b></li>
<ul>
<li>Active velocity on infeed and outfeed of station</li>
</ul>
<li><b>rAccDec :</b></li>
<ul>
<li>Active dyn constraint</li>
</ul>
<li><b>rJerk :</b></li>
<ul>
<li>Active dyn constraint</li>
</ul>
<li><b>nConfiguredStopCount :</b></li>
<ul>
<li>Count of PosStop (nests) a mover may has to stop at in XtsStation</li>
</ul>
<li><b>rPosStop[] :</b></li>
<ul>
<li>Relative to rPosWait</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>TransportUnit</li>
<ul>
<li>Fb_TransportUnit():</li>
<ul>
<li>Top level control of XtsTransport</li>
<li>Cycle check for change of command:</li>
<ul>
<li><b>E_XTS_TRANSPORT_CTRL:</b></li>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>TransportUnit</li>
<ul>
<li>Fb_TransportUnit():</li>
<ul>
<li>Members:</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>TransportUnit</li>
<ul>
<li>Fb_TransportUnit():</li>
<ul>
<li>Change of command triggers execution</li>
<li>Execution result is added to state</li>
<li>Extern control needs to react to BUSY, DONE or ERROR</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>TransportUnit</li>
<ul>
<li>GVL_XTS.XtsTransportCtrl: <b>ST_TRANSPORT_UNIT_CTRL
</b></li>
<ul>
<li>Struct for commanding FB_TransportUnit
</li>
<li>eCmd : E_XTS_TRANSPORT_CTRL</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>TransportUnit</li>
<ul>
<li>GVL_XTS.XtsTransportState: <b>ST_TRANSPORT_UNIT_STATE
</b></li>
<li>State: combines active command and result
</li>
<li>Check: cyclic pointer checks
</li>
<li>XpuState: state from fb_Xpu
</li>
<li>XpuInfo: cyclic plausibility checks to TcCOM Objects
</li>
<li>GroupInfo: cyclic information from FB_CaGroup</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Mover[] (<b>fb_MoverCtrl</b>)</li>
<ul>
<li>Inherits <b>fb_Mover</b></li>
<ul>
<li>Access to MC function blocks in library</li>
<li>Implements Interface for use in other classes
</li>
</ul>
<li>Contains cyclic interface</li>
<ul>
<li>OnChange check of command</li>
<li>Ctrl datafield for setting commands</li>
<li>State data field for checking responses</li>
<li>Parameter datafields for using motion functions </li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_MoverCtrl:</li>
<ul>
<li>Mover index is passed as value from caller
</li>
<li>Global datafields are passed as references (<b>REF=</b>) into fb_MoverCtrl properties</li>
<ul>
<li>OnChange Ctrl / State: handshakes</li>
<ul>
<li>standard return value for method <b>(E_PROGRESS)
</b></li>
</ul>
<li>OnExec log LastPosition of CA/MC function
</li>
<li>OnExec log LastGap on CA function</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_CaGroup:</li>
<ul>
<li>Collision Avoidance class wrapper
</li>
<li>Implements <b>I_Transport_CaGroup
</b></li>
<li>Cyclic information from <b>AXES_GROUP_REF
</b></li>
<li>Mover commands via interface <b>I_XtsTransport_Mover</b></li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_CaGroup:</li>
<ul>
<li>Implements <b>I_Transport_CaGroup</b></li>
<ul>
<li>Used in fb_TransportUnit</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_CaGroup:</li>
<ul>
<li>Cyclic information to <b>ST_GROUP_INFO </b></li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Xpu (<b>fb_XpuCtrl</b>)
</li>
<ul>
<li>Inherits <b>fb_Xpu</b>:</li>
<ul>
<li>Class for interacting with XTS ProcessingUnit</li>
<li>XpuInit()</li>
<ul>
<li>Connects to OTCIDs of XTS TcCOM Objects</li>
</ul>
<li>Cycle</li>
<ul>
<li>Plausibitlity checks, get module info data</li>
</ul>
<li>ModuleInfoData, used in Cycle</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>GVL_XTS.Xpu (<b>fb_XpuCtrl</b>) 
</li>
<ul>
<li>Wraps cyclic execution of fb_Xpu
</li>
<li>Cyclic check for command change
<b>(ST_XPU_CTRL.Cmd)</b></li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_XpuCtrl cyclic data:
</li>
<ul>
<li><b>SUPER^.Cycle():</b></li>
<ul>
<li>Cyclic plausibility checks</li>
<li>Cyclic update motor modules data
</li>
</ul>
<li>Cyclic data <b>ST_XPU_INFO:</b></li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_XpuCtrl:</li>
<ul>
<li>Cyclic motor module data:</li>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_XpuCtrl:
</li>
<ul>
<li><b>DetectMoverId:</b></li>
<ul>
<li>Cyclic checks for valid Mover ID Detection</li>
<li>Check pdf flowchart in [doc] folder of project</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu.GetEnvironment():
</li>
<ul>
<li><b>Interface methods to Tc3_XTS_Utility.lib:</b></li>
<ul>
<li>GetEnvironment() : I_TcIoXtsEnvironment</li>
<ul>
<li>Startup initialization of _fbEnvironment is done
 by fb_Xpu.Init()
</li>
<li>Top level interface</li>
<ul>
<li>See interface structure (Library Manager) in order to reach lower level interfaces</li>
</ul>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu.GetEnvironment():
</li>
<ul>
<li><b>I_TcIoXtsEnvironment:</b></li>
<ul>
<li>See LibraryManager</li>
<li>Provides access to members</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu.GetProcessingUnit():
</li>
<ul>
<li><b>Interface methods to Tc3_XTS_Utility.lib:</b></li>
<ul>
<li>GetProcessingUnit : I_TcIoXtsProcessingUnit</li>
<ul>
<li>Startup initialization of _fbProcessingUnit is done by fb_Xpu.Init()
</li>
<li>Interface for Processing Unit</li>
<ul>
<li>See interface structure (Library Manager) in order to reach lower level interfaces</li>
</ul>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu.GetProcessingUnit():
</li>
<ul>
<li><b>I_TcIoXtsProcessingUnit:</b></li>
<ul>
<li>See LibraryManager</li>
<li>Provides access to members</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu.GetParameterSet(Index):
</li>
<ul>
<li><b>Interface methods to Tc3_XTS_Utility.lib:</b></li>
<ul>
<li>GetParameterSet(Index) : I_TcIoXtsParameterSet</li>
<ul>
<li>Startup initialization of _fbParameterSet[ ] is done by fb_Xpu.Init()
</li>
<li>Interface for ParameterSets</li>
<ul>
<li>See interface structure (Library Manager) in order to reach lower level interfaces</li>
</ul>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu.GetParameterSet(Index):
</li>
<ul>
<li><b>I_TcIoXtsParameterSet:</b></li>
<ul>
<li>See LibraryManager</li>
<li>Provides access to members</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu.GetXpuMover(Index):
</li>
<ul>
<li><b>Interface methods to Tc3_XTS_Utility.lib:</b></li>
<ul>
<li>GetXpuMover(Index) : I_TcIoXtsXpuMover</li>
<ul>
<li>Startup initialization of _fbMoverXpu[ ] is done
 by fb_Xpu.Init()
</li>
<li>Interface for Mover</li>
<ul>
<li>See interface structure (Library Manager) in order to reach lower level interfaces</li>
</ul>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu. GetXpuMoverByAxisId(AxisId):
</li>
<ul>
<li><b>Interface methods to Tc3_XTS_Utility.lib:</b></li>
<ul>
<li>GetXpuMoverByAxisId(AxisId): I_TcIoXtsXpuMover</li>
<ul>
<li>Startup initialization of _fbMoverXpu[ ] is done
 by fb_Xpu.Init()
</li>
<li>Interface for Mover</li>
<ul>
<li>See interface structure (Library Manager) in order to reach lower level interfaces</li>
</ul>
</ul>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>3. Design</b></h1>
<ul>
<li>fb_Xpu.GetXpuMover(Index):</li>
<li>fb_Xpu.GetXpuMoverByAxisId(AxisId):
</li>
<ul>
<li><b>I_TcIoXtsXpuMover:</b></li>
<ul>
<li>See LibraryManager</li>
<li>Provides access to members</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>4. Examples</b></h1>
<ul>
<li><b>Transport Logic can be easy or may be complex
</b></li>
<ul>
<li><b>Examples shall help you to easily build any product transport.</b></li>
<ul>
<li>Please contact me via github; the place where you found this repo ;-)</li>
<h2><b></b></h2>
</ul>
<li>All examples consider one specific aspect of the XTS transport system</li>
<ul>
<li>Work as simple IndexTable</li>
<li>Work as Index Table where processes may host a number of XtsStations, working in parallel.</li>
<li>Complex, lot based decisions in order to achieve maximum production flexibility in one machine</li>
<li>Fast and precise for high speed packaging machines</li>
<li>Fast, synchronuous and precise for high end sorting and/or assembly machines</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>4. Examples</b></h1>
<ul>
<li>XTS_DEMO_11</li>
<ul>
<li>Single Station, Single Nest</li>
<ul>
<li>ST_STATION_CTRL/ST_STATION_STATE is used for mover handshakes</li>
</ul>
<li>Easy example for a XTS transport which requires only stations in which a mover stops once.</li>
<li>Easy transport logic;</li>
<h2>Target[n] := n+1; n+1 &gt; MAX; n+1 := 1
</h2>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>4. Examples</b></h1>
<ul>
<li>XTS_DEMO_22</li>
<ul>
<li>Multiple XPU</li>
<ul>
<li>2 ProcessingUnits in one PLC
</li>
</ul>
<li>Single Station, Single Nest</li>
<ul>
<li>ST_STATION_CTRL/ST_STATION_STATE is used for mover handshakes</li>
</ul>
<li>Easy example for an XTS transport requiring only stations in which a mover stops once.
</li>
<li>Easy transport logic:</li>
<h2>Target[n] := n+1; n+1 &gt; MAX; n+1 := 1
</h2>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>4. Examples</b></h1>
<ul>
<li>XTS_DEMO_APPLICATION_108</li>
<ul>
<li>High volume packaging application</li>
<li>450 – 500 Mover/Minute</li>
<li>INFEED with gaps [1..12] possible</li>
<li>Any OUTFEED without gaps</li>
<ul>
<li>12 Movers per outfeed</li>
</ul>
<li>4 OUTFEED scenarios</li>
<ul>
<li>software switch (PLC)</li>
<li>R1 or 	 R2</li>
<li>R1 and R2</li>
<li>R1 xor R2</li>
<li>CLAMP
</li>
</ul>
</ul>
</ul>
<ul>
<li> </li>
<ul>
<li>Complex transport logic:</li>
<ul>
<li>fb_ProcessCollector: grouping of XtsStations</li>
<li>fb_Instance: base class for logic implementation</li>
<li>Process_Instances: extending fb_Instance with transport details
</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>4. Examples</b></h1>
<ul>
<li>XTS_DEMO_LASER_CUT</li>
<ul>
<li>Flying Saw application with 3 XPU</li>
<li>ConveyerBelt MasterAxis</li>
<li>CutMark detection (simulated in example)</li>
<li>GearInPosCA for 3 XPU with 6 Movers each</li>
<li>Use of multiple PLC</li>
<ul>
<li>XtsTransport</li>
<li>ExternControl</li>
</ul>
</ul>
</ul>
<ul>
<li> </li>
<ul>
<li>Complex transport logic:</li>
<ul>
<li>fb_ProcessCollector: grouping of XtsStations</li>
<li>fb_Instance: base class for logic implementation</li>
<li>Process_Instances: extending fb_Instance with transport details</li>
<li>fb_GearInPos extends fb_StationBase</li>
<li>Control and Feedback datafields for ADS or fieldbus access
</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>4. Examples</b></h1>
<ul>
<li>XTS_DEMO_DISPENSING_MOVER</li>
<ul>
<li>Station based example</li>
<li>Dispensing Station</li>
<ul>
<li>GearIn of Mover in Station (standstill)</li>
<li>Select *.nc file </li>
<li>Build NCI Config</li>
<li>Activate NCI config</li>
<li>Start *.nc program</li>
<li>Use of Mfunc to start dispenser axis</li>
</ul>
<li>Use of PLC_MOTION_LAYER</li>
<ul>
<li><a href="https://github.com/haud-ba/PLC_MOTION_LAYER"><u>https://github.com/haud-ba/PLC_MOTION_LAYER</u></a></li>
</ul>
</ul>
</ul>
<ul>
<li> </li>
<ul>
<li>Complex transport logic:</li>
<ul>
<li>fb_ProcessCollector: grouping of XtsStations</li>
<li>fb_Instance: base class for logic implementation</li>
<li>Process_Instances: extending fb_Instance with transport details</li>
</ul>
</ul>
</ul>
<h1 style="page-break-before:always; "><b>5. LICENSE</b></h1>
<h2><b>XTS_TRANSPORT_LAYER project</b></h2>
<h2>MIT License</h2>
<h2>Copyright (c) 2025 HAUD
</h2>
<h2>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

<b>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

</b>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.</h2>
<h1 style="page-break-before:always; ">05/2024</h1>
<h2>05/2024</h2>
<h1 style="page-break-before:always; "> 05/2024</h1>
<h2> 05/2024</h2>
</body>
</html>