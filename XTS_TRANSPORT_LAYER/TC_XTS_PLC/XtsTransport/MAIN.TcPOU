<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.13">
  <POU Name="MAIN" Id="{f2e9720a-bda2-4399-8c7d-d9b6e11179c8}" SpecialFunc="None">
    <Declaration><![CDATA[//---------------------------------------------------------------------------------------------------------------
//
//  HAUD 2026.02.11
//  - transport layer new member:
//    - MoverSelector
//      - Cyclic movement execution class
//      - mapping unions available
//      - Mover selection (one mover at a time)
//      - composition using I_XtsTransport_Mover
//
//
//---------------------------------------------------------------------------------------------------------------
//
//  HAUD 2025.12.04
//
//  - XTS_TRANSPORT_LAYER
//  - transport layer members:
//    - MessageData
//      - ABSTRACT base class
//        - cyclic wrapper
//
//      - device driven message list implementation
//        - e_Device.Metrics: message list dedicated for performance logs
//
//      - new e_MessageType
//        -  eMessageBatch: may be used for performance metric messages
//
//    - CaGroup
//      - access to Group functions
//
//    - Mover
//      - Base class
//        - cyclic wrapper
//
//      - access to MC and CA motion functions
//
//    - Xpu (ProcessingUnit)
//      - Base class
//        - cyclic wrapper
//
//      - access to TcCOM Objects in Environment
//
//    - Transport Control Unit
//      - coordinates members to get XTS in defined states
//
//    - Xts Stations
//      - ABSTRACT base class
//        - used via inheritance
//
//      - handshakes with extern control for mover transport
//
//  - global datafields for mrmbers in GVL_XTS namespace
//  - global interface datafields for use in members
//  - structures are assigned by reference for every member
//
//---------------------------------------------------------------------------------------------------------------
// HAUD 2025 08 29
//
//    XTS_TRANSPORT_LAYER project
//    
//    MIT License
//    
//    Copyright (c) 2025 HAUD
//    
//    Permission is hereby granted, free of charge, to any person obtaining a copy
//    of this software and associated documentation files (the "Software"), to deal
//    in the Software without restriction, including without limitation the rights
//    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//    copies of the Software, and to permit persons to whom the Software is
//    furnished to do so, subject to the following conditions:
//    
//    The above copyright notice and this permission notice shall be included in all
//    copies or substantial portions of the Software.
//    
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//    SOFTWARE.
//---------------------------------------------------------------------------------------------------------------
PROGRAM MAIN
VAR
	bInit 				          : BOOL;
  eInit                   : E_PROGRESS;

  nStation,
	nMover,
  nMoverSelected,
  nStationSelected,
  nStationParameter       : UINT;

  sStationText            : STRING(30);
  stXpuStrings            : ST_XPU_STRINGS;

  eTransportState         : E_XTS_TRANSPORT_STATE;
  eTransportResult        : E_PROGRESS;

  eXpuState               : E_XPU_STATE;
  eXpuResult              : E_PROGRESS;
  eXpuCheck               : E_XPU_CHECK;

  eSelectorState,
  eMoverState             : E_MOVER_STATE;

  eSelectorResult,
  eMoverResult            : E_PROGRESS;

  sSelectorState,
  sSelectorResult,
  sCaGroupState,
  sTransportState,
  sTransportCheck,
  sTransportResult,
  sMoverState,
  sMoverResult,
  sStationState,
  sStationStateMask,
  sStationCtrlMask        : STRING;

  bStationEnable,
  bStationEnter,
  bStationStart,
  bStationDone,
  bStationOut,
  bStationGone            : BOOL;

  tStationSelectedQueue   : ARRAY[1..MAX_LIST_NODES] OF ST_STATION_MOVER_DATA;

  nStn                    : UINT;

  stMsg                   : ST_Message;
  eMsgState               : e_message_state;
  eMsgProgress            : E_PROGRESS;
  eMtrState               : e_message_state;
  eMtrProgress            : E_PROGRESS;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//############################################################################
// Local time; used for timestamps
//############################################################################
GVL_MSG.fbLocalTime(
                    sLocalTime          => GVL_MSG.sLocalTime, 
                    dtLocalTime         => GVL_MSG.dtLocalTime);
//############################################################################
//############################################################################
// 	example for init sequence
//############################################################################	
IF NOT bInit
THEN
  CASE eInit
  OF
    E_PROGRESS.PROGRESS_INVALID,
    E_PROGRESS.PROGRESS_DONE:         // clear command interface
      eInit                                     := E_PROGRESS.PROGRESS_BUSY;
      GVL_XTS.XpuCtrl.Cmd                       := E_XPU_CTRL.XTS_CMD_NULL;
      GVL_MSG.TransportMessageCtrl.Cmd          := E_MESSAGE_CTRL.MSG_CTRL_NULL;
      GVL_MSG.MetricsMessageCtrl.Cmd            := E_MESSAGE_CTRL.MSG_CTRL_NULL;


      GVL_MSG.MessageLevelXpu                   := E_MessageType.eMessageVerbose; //GVL_MSG.MessageLevel;
      GVL_XTS.CaGroup.MessageLevel              := E_MessageType.eMessageVerbose; //GVL_MSG.MessageLevel;
      GVL_XTS.XtsTransport.MessageLevel         := E_MessageType.eMessageVerbose; //GVL_MSG.MessageLevel;

      FOR nStation := 1 TO MAX_STATION
      DO
        GVL_MSG.MessageLevelStations[nStation]  := E_MessageType.eMessageVerbose; //GVL_MSG.MessageLevel;
      END_FOR
      FOR nMover := 1 TO MAX_MOVER
      DO
        GVL_MSG.MessageLevelMovers[nMover]      := E_MessageType.eMessageVerbose; //GVL_MSG.MessageLevel;
      END_FOR

      
    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    E_PROGRESS.PROGRESS_BUSY:         // init Xpu, ProcessingUnit, MotorModules
      eInit                                     := E_PROGRESS.PROGRESS_PREPARE;
      GVL_XTS.XpuCtrl.Cmd                       := E_XPU_CTRL.XTS_CMD_INIT;
      GVL_MSG.TransportMessageCtrl.Cmd          := E_MESSAGE_CTRL.MSG_CTRL_INIT;
      GVL_MSG.MetricsMessageCtrl.Cmd            := E_MESSAGE_CTRL.MSG_CTRL_INIT;

    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    E_PROGRESS.PROGRESS_PREPARE:      // wait for init to be done
      IF (GVL_XTS.XpuState.State      = E_XPU_STATE.XTS_INIT + E_PROGRESS.PROGRESS_error)
      THEN
        stMsg.eDevice                           := e_Device.Device_Main;
        stMsg.eSubdevice                        := e_Subdevice.MainInit;
        stMsg.iErrorNumber                      := GVL_XTS.XpuState.Check;
        stMsg.sText                             := concat('MAIN.eInit Error: ', TO_STRING(MAIN.eInit));
        stMsg.sText                             := concat(stMsg.sText , ': ');
        stMsg.sText                             := concat(stMsg.sText, 'XpuState.Check: ');
        stMsg.sText                             := concat(stMsg.sText, TO_STRING(GVL_XTS.XpuState.Check));

        eInit                                   := E_PROGRESS.PROGRESS_ERROR;

      ELSIF (GVL_XTS.XpuState.State   = E_XPU_STATE.XTS_INIT + E_PROGRESS.PROGRESS_DONE)
      THEN
        eInit                                   := E_PROGRESS.PROGRESS_STARTUP;
        GVL_XTS.XpuCtrl.Cmd                     := E_XPU_CTRL.XTS_IDLE;
      END_IF

    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    E_PROGRESS.PROGRESS_STARTUP:
      eInit                                     := E_PROGRESS.PROGRESS_CHECK;

    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    E_PROGRESS.PROGRESS_CHECK:
      eInit                                     := E_PROGRESS.PROGRESS_OCCUPIED;

    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    E_PROGRESS.PROGRESS_OCCUPIED:     // StartStation for XtsTransportCtrl.Cmd := E_XTS_TRANSPORT_CTRL.CMD_TRANSPORT_START;
      eInit                                     := E_PROGRESS.PROGRESS_WORKING;
      // where are the stations?
      // TODO: after importing this project into your XTS TwinCAT solution, setup of Station parameters is required.

    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    E_PROGRESS.PROGRESS_WORKING:
      // Start Position parameters
      // where to start?
      // TODO: after import --> setup of start parameters required


      IF (GVL_XTS.XtsTransport.StationStartIndex > 0) AND
         (GVL_XTS.XtsTransport.StationStartIndex < MAX_STATION+1)
      THEN
        GVL_XTS.StationStart.nConfiguredStopCount := GVL_XTS.StationParameter[GVL_XTS.XtsTransport.StationStartIndex].nConfiguredStopCount;
      END_IF

      bInit                                     := TRUE;
      eInit                                     := E_PROGRESS.PROGRESS_DONE;
  END_CASE
END_IF
//############################################################################
//############################################################################
// 	/XTS Transport Unit
//############################################################################
//  - main control function block for transport layer
//  - requires access to member controls
//    - Xpu
//    - CaGroup
//    - Mover
//    - Station Control
//    - Station LinkedList Interface
//############################################################################
//
// cyclic call
GVL_XTS.XtsTransport();

// main control
GVL_XTS.XtsTransport.Ctrl               REF= GVL_XTS.XtsTransportCtrl;   // main control
GVL_XTS.XtsTransport.State              REF= GVL_XTS.XtsTransportState;  // main state
                                        
// member controls                      
GVL_XTS.XtsTransport.XpuCtrl            REF= GVL_XTS.XpuCtrl;
GVL_XTS.XtsTransport.XpuState           REF= GVL_XTS.XpuState;
GVL_XTS.XtsTransport.XpuInfo            REF= GVL_XTS.XpuInfo;
                                        
GVL_XTS.XtsTransport.GroupItf           :=   GVL_XTS.CaGroupItf;
GVL_XTS.XtsTransport.GroupInfo          REF= GVL_XTS.CaGroupInfo;
                                        
GVL_XTS.XtsTransport.MoverItf           REF= GVL_XTS.MoverItf;
GVL_XTS.XtsTransport.MoverInfo          REF= GVL_XTS.MoverInfo;
GVL_XTS.XtsTransport.MoverLastPosition  REF= GVL_XTS.LastPosition;
GVL_XTS.XtsTransport.MoverLastGap       REF= GVL_XTS.LastGap;

GVL_XTS.XtsTransport.StationStartIndex  :=   GVL_XTS.StationStartIndex;                                        
GVL_XTS.XtsTransport.StationStart       REF= GVL_XTS.StationStart;      // start position for E_XTS_TRANSPORT_CTRL.CMD_TRANSPORT_START
GVL_XTS.XtsTransport.StationCtrlItf     REF= GVL_XTS.StationCtrlItf;    // station interfaces are required for accessing station methods
GVL_XTS.XtsTransport.StationListsItf    REF= GVL_XTS.StationListItf;    // list interface is required for access to linked list methods
GVL_XTS.XtsTransport.StationControl     REF= GVL_XTS.StationCtrl;
GVL_XTS.XtsTransport.StationState       REF= GVL_XTS.StationState;
//############################################################################
// 	XTS Transport Unit/
//############################################################################
//############################################################################
//############################################################################
// 	/XTS Stations
//############################################################################	
FOR nStation := 1 TO MAX_STATION
DO
  CASE GVL_XTS.StationParameter[nStation].eType
  OF
    //-----------------------------------------------------------------------------
    E_STATION_TYPE.STATION_PROCESS:

      GVL_XTS.Station[nStation].StationId     := nStation;
      GVL_XTS.Station[nStation].MessageLevel  := GVL_MSG.MessageLevelStations[nStation];
    
      GVL_XTS.StationListItf[nStation]        := GVL_XTS.StationList[nStation];   // interfaces for list methods
      GVL_XTS.StationCtrlItf[nStation]        := GVL_XTS.Station[nStation];       // interfaces for station methods
    
      GVL_XTS.Station[nStation].Ctrl          REF= GVL_XTS.StationCtrl;           // station ctrl from extern
      GVL_XTS.Station[nStation].State         REF= GVL_XTS.StationState;          // station state to extern
    
      GVL_XTS.Station[nStation].ItfStations   REF= GVL_XTS.StationListItf;        // give every station all list interfaces for writing mover tickets
      GVL_XTS.Station[nStation].ItfMover      REF= GVL_XTS.MoverItf;              // give every station all mover interfaces for movement in / out of station
      GVL_XTS.Station[nStation].Mover         REF= GVL_XTS.AxisRefMover;          // AXIS_REF to read infos from
      GVL_XTS.Station[nStation].MoverOffset   REF= GVL_XTS.PositionOffset;        // static offsets for all stations, all movers, all stop positions
    
      GVL_XTS.Station[nStation].StationParameter  REF= GVL_XTS.StationParameter;// give every station all station parameters for sending to WaitPos of target station
    
      // cyclic call
      GVL_XTS.Station[nStation].Cycle();                                        // cycle for handshaking with extern
    
      // Queue data for each station
      GVL_XTS.StationQueue[nStation]          := GVL_XTS.StationListItf[nStation].Data;


    //-----------------------------------------------------------------------------
    E_STATION_TYPE.STATION_GEAR_IN_POS:

      GVL_XTS.StationGearIn[nStation].StationId   := nStation;
      GVL_XTS.StationGearIn[nStation].MessageLevel:= GVL_MSG.MessageLevelStations[nStation];
    
      GVL_XTS.StationListItf[nStation]            := GVL_XTS.StationList[nStation];   // interfaces for list methods
      GVL_XTS.StationCtrlItf[nStation]            := GVL_XTS.StationGearIn[nStation]; // interfaces for station methods
    
      GVL_XTS.StationGearIn[nStation].Ctrl        REF= GVL_XTS.StationCtrl;           // station ctrl from extern
      GVL_XTS.StationGearIn[nStation].State       REF= GVL_XTS.StationState;          // station state to extern
    
      GVL_XTS.StationGearIn[nStation].ItfStations REF= GVL_XTS.StationListItf;        // give every station all list interfaces for writing mover tickets
      GVL_XTS.StationGearIn[nStation].ItfMover    REF= GVL_XTS.MoverItf;              // give every station all mover interfaces for movement in / out of station
      GVL_XTS.StationGearIn[nStation].Mover       REF= GVL_XTS.AxisRefMover;          // AXIS_REF to read infos from
      GVL_XTS.StationGearIn[nStation].MoverOffset REF= GVL_XTS.PositionOffset;        // static offsets for all stations, all movers, all stop positions
    
    
      GVL_XTS.StationGearIn[nStation].StationParameter  REF= GVL_XTS.StationParameter;// give every station all station parameters for sending to WaitPos of target station
    
      // cyclic call
      GVL_XTS.StationGearIn[nStation].Cycle();                                        // cycle for handshaking with extern
    
      // Queue data for each station
      GVL_XTS.StationQueue[nStation]        := GVL_XTS.StationListItf[nStation].Data;
  END_CASE
END_FOR
//############################################################################
// 	XTS Stations/
//############################################################################	
//############################################################################
//############################################################################
// 	/XPU environment
//############################################################################	
GVL_XTS.Xpu.XpuInstance               :=   1;
GVL_XTS.Xpu.MessageLevel              :=   GVL_MSG.MessageLevelXpu;

GVL_XTS.Xpu.Ctrl                      REF= GVL_XTS.XpuCtrl;
GVL_XTS.Xpu.State                     REF= GVL_XTS.XpuState;
GVL_XTS.Xpu.XpuModuleInfoData         REF= GVL_XTS.XpuModules;

GVL_XTS.Xpu.CaGroupOID                :=   GVL_XTS.CaGroup.GroupInfo.CaGroupOID;

// cyclic call
GVL_XTS.Xpu();
GVL_XTS.XpuInfo                       :=   GVL_XTS.Xpu.XpuInfo;
//############################################################################
// 	XPU environment/
//############################################################################	
//############################################################################
//############################################################################	
// 	/CA-Group Class
//############################################################################
// message device identifier
GVL_XTS.CaGroup.MessageDeviceIndex    :=   e_Device.CaGroup + 1;	
// assignment
GVL_XTS.CaGroup.AxisRef               REF= GVL_XTS.AxisRefMover;
// Interface to Mover methods
GVL_XTS.CaGroup.MoverItf              REF= GVL_XTS.MoverItf; 

GVL_XTS.CaGroup.GroupRef              REF= GVL_XTS.CaGroupRef;

GVL_XTS.CaGroup.XpuInfo               REF= GVL_XTS.XpuInfo;

// cyclic call
GVL_XTS.CaGroup.InfoCycle(TRUE); // read group status

// InfoData from group
GVL_XTS.CaGroupInfo                   :=   GVL_XTS.CaGroup.GroupInfo;

// Interface of CaGroup
GVL_XTS.CaGroupItf                    :=   GVL_XTS.CaGroup;
//############################################################################	
// 	CA-Group Class/
//############################################################################
//############################################################################
//############################################################################
//  /Mover Class	
//############################################################################	
FOR nMover := 1 TO XTS_Parameter.MAX_MOVER
DO
  GVL_XTS.Mover[nMover].MoverId         :=   nMover;
  GVL_XTS.Mover[nMover].RailLength      :=   GVL_XTS.Xpu.RailLength;  // mover needs RailLength, in order to calc absolute position from modulo input
  GVL_XTS.Mover[nMover].MessageLevel    :=   GVL_MSG.MessageLevelMovers[nMover];

  GVL_XTS.Mover[nMover].Ctrl            REF= GVL_XTS.MoverCtrl;       // mover control from extern
  GVL_XTS.Mover[nMover].State           REF= GVL_XTS.MoverState;      // mover state to extern

  GVL_XTS.Mover[nMover].MoveData        REF= GVL_XTS.MoveData;        // dyn constraints for extern to write
  GVL_XTS.Mover[nMover].GearData        REF= GVL_XTS.GearData;        // GearIn/GearInPosCa data fro extern to write

  // assignment	
  GVL_XTS.Mover[nMover].Mover           REF= GVL_XTS.AxisRefMover[nMover];  // axis reference to Mover function block
  GVL_XTS.Mover[nMover].LastGap         REF= GVL_XTS.LastGap[nMover];       // reference to last used gap value datafield
  GVL_XTS.Mover[nMover].LastPosition    REF= GVL_XTS.LastPosition[nMover];  // reference to last position datafield

  GVL_XTS.Mover[nMover].MoverInfo		    REF= GVL_XTS.MoverInfo[nMover];     // refernence to mover info data (ActPos, SetPos, ...)

  GVL_XTS.MoverItf[nMover]              :=   GVL_XTS.Mover[nMover];

  // cyclic call
  GVL_XTS.Mover[nMover].Cycle();  // call AXIS_REF()
  GVL_XTS.Mover[nMover]();        // call Ctrl/State
END_FOR
//############################################################################
//  Mover Class/	
//############################################################################	
//############################################################################
//############################################################################
//  /Mover Selector	
//############################################################################
GVL_XTS.MoverSelector.Ctrl              REF= GVL_XTS.SelectorCtrl;
GVL_XTS.MoverSelector.State             REF= GVL_XTS.SelectorState;
GVL_XTS.MoverSelector.AxisRef           REF= GVL_XTS.AxisRefMover;
GVL_XTS.MoverSelector.Info              REF= GVL_XTS.MoverInfo;
GVL_XTS.MoverSelector.ItfMover          REF= GVL_XTS.MoverItf;

GVL_XTS.MoverSelector();
//############################################################################
//  Mover Selector/	
//############################################################################	
//############################################################################
//############################################################################
//  /logging
//    - all life is problem solving
//############################################################################
GVL_MSG.TransportMessageData.Ctrl             REF= GVL_MSG.TransportMessageCtrl;
GVL_MSG.TransportMessageData.State            REF= GVL_MSG.TransportMessageState;

GVL_MSG.TransportMessageData.MessageIndex     REF= GVL_MSG.MessageTransportIndex;
GVL_MSG.TransportMessageData.ErrorIndex       REF= GVL_MSG.MessageTransportError;

GVL_MSG.TransportMessageData.DirRoot          :=   ADR(GVL_MSG.LOG_DIR);
GVL_MSG.TransportMessageData.FileRoot         :=   ADR(GVL_MSG.LOG_FILE);

GVL_MSG.TransportMessageData.MsgList          :=   ADR(GVL_MSG.TransportMessages);
GVL_MSG.TransportMessageData.LocalTime        :=   ADR(GVL_MSG.dtLocalTime);

GVL_MSG.TransportMessageData();               

eMsgState                                     :=   f_GetState   (GVL_MSG.TransportMessageState.State);
eMsgProgress                                  :=   f_GetProgress(GVL_MSG.TransportMessageState.State);

CASE eMsgState
OF
  E_MESSAGE_STATE.MSG_STATE_NULL:
    CASE eMsgProgress
    OF
      E_PROGRESS.PROGRESS_INVALID,
      E_PROGRESS.PROGRESS_DONE:
        IF (GVL_MSG.MessageTransportIndex > GVL_MSG.MAX_MESSAGE/100) OR
           (GVL_MSG.MessageTransportError > 0)
        THEN
          GVL_MSG.TransportMessageCtrl.Cmd    := E_MESSAGE_CTRL.MSG_CTRL_WRITE;
        END_IF
    END_CASE

  E_MESSAGE_STATE.MSG_STATE_WRITE:
    CASE eMsgProgress
    OF
      E_PROGRESS.PROGRESS_ERROR,
      E_PROGRESS.PROGRESS_DONE:
        GVL_MSG.TransportMessageCtrl.Cmd      := E_MESSAGE_CTRL.MSG_CTRL_NULL;
    END_CASE

ELSE
    CASE eMsgProgress
    OF
      E_PROGRESS.PROGRESS_DONE:
        GVL_MSG.TransportMessageCtrl.Cmd      := E_MESSAGE_CTRL.MSG_CTRL_NULL;
    END_CASE
END_CASE
//############################################################################
//  logging/
//############################################################################
//############################################################################
//############################################################################
//  /Transport Metrics
//############################################################################
GVL_MSG.MetricsMessageData.Ctrl               REF= GVL_MSG.MetricsMessageCtrl;
GVL_MSG.MetricsMessageData.State              REF= GVL_MSG.MetricsMessageState;

GVL_MSG.MetricsMessageData.MessageIndex       REF= GVL_MSG.MessageMetricsIndex;
GVL_MSG.MetricsMessageData.ErrorIndex         REF= GVL_MSG.MessageMetricsError;

GVL_MSG.MetricsMessageData.DirRoot            :=   ADR(GVL_MSG.LOG_DIR);
GVL_MSG.MetricsMessageData.FileRoot           :=   ADR(GVL_MSG.LOG_FILE_METRIC);

GVL_MSG.MetricsMessageData.MsgList            :=   ADR(GVL_MSG.MetricsMessages);
GVL_MSG.MetricsMessageData.LocalTime          :=   ADR(GVL_MSG.dtLocalTime);

GVL_MSG.MetricsMessageData();

eMtrState                                     := f_GetState   (GVL_MSG.MetricsMessageState.State);
eMtrProgress                                  := f_GetProgress(GVL_MSG.MetricsMessageState.State);

CASE eMtrState
OF
  E_MESSAGE_STATE.MSG_STATE_NULL:
    CASE eMtrProgress
    OF
      E_PROGRESS.PROGRESS_INVALID:
        IF (GVL_MSG.MessageMetricsIndex > GVL_MSG.MAX_MESSAGE/100) OR
           (GVL_MSG.MessageMetricsError > 0)
        THEN
          GVL_MSG.MetricsMessageCtrl.Cmd      := E_MESSAGE_CTRL.MSG_CTRL_WRITE;
        END_IF
    END_CASE

  E_MESSAGE_STATE.MSG_STATE_WRITE:
    CASE eMtrProgress
    OF
      E_PROGRESS.PROGRESS_ERROR,
      E_PROGRESS.PROGRESS_DONE:
        GVL_MSG.MetricsMessageCtrl.Cmd        := E_MESSAGE_CTRL.MSG_CTRL_NULL;
    END_CASE
ELSE
    CASE eMtrProgress
    OF
      E_PROGRESS.PROGRESS_DONE:
        GVL_MSG.MetricsMessageCtrl.Cmd        := E_MESSAGE_CTRL.MSG_CTRL_NULL;
    END_CASE
END_CASE
//############################################################################
//  Transport Metrics/
//############################################################################
//############################################################################
//############################################################################
//  /Visualization data	
//############################################################################
VisualizationData();
//############################################################################
//  Visualization data/	
//############################################################################
]]></ST>
    </Implementation>
    <Action Name="VisualizationData" Id="{ef1aa6aa-d8a0-407a-9f2c-db2f36c6cbf2}">
      <Implementation>
        <ST><![CDATA[//############################################################################
//############################################################################
// Visualization data	
//############################################################################
// get enumerations from XPU for visu:	
eTransportState                       := f_GetState   (GVL_XTS.XtsTransportState.State);
eTransportResult                      := f_GetProgress(GVL_XTS.XtsTransportState.State);

eXpuState                             := f_GetState   (GVL_XTS.XtsTransportState.XpuState.State);
eXpuResult                            := f_GetProgress(GVL_XTS.XtsTransportState.XpuState.State);

eXpuCheck                             := GVL_XTS.XtsTransportState.XpuState.Check;

// display xpu state and result in visu
// get strings and info
sCaGroupState                         := TO_STRING(GVL_XTS.XtsTransportState.GroupInfo.CaGroupState);

sTransportState                       := TO_STRING(eTransportState);
sTransportCheck                       := TO_STRING(GVL_XTS.XtsTransportState.Check);
sTransportResult                      := TO_STRING(eTransportResult);

stXpuStrings.sXpuState                := TO_STRING(eXpuState);
stXpuStrings.sXpuResult               := TO_STRING(eXpuResult);
stXpuStrings.sXpuCyclicCheck          := TO_STRING(eXpuCheck);

stXpuStrings.sXpuOpMode               := GVL_XTS.Xpu.OpModeToString();
stXpuStrings.sXpuMoverId_DetectionMode:= GVL_XTS.Xpu.IdDetectionModeToString();
stXpuStrings.sXpuMoverPosAssignement  := GVL_XTS.Xpu.MoverPositionAssignementToString();

nMoverSelected                        := SEL((nMoverSelected<1), nMoverSelected, 1);
nMoverSelected                        := SEL((nMoverSelected>MAX_MOVER), nMoverSelected, MAX_MOVER);

nStationSelected                      := SEL((nStationSelected<1), nStationSelected, 1);
nStationSelected                      := SEL((nStationSelected>MAX_STATION), nStationSelected, MAX_STATION);

bStationEnable                        := SEL((GVL_XTS.StationCtrl[nStationSelected].Cmd = E_STATION_CTRL.STATION_ENABLE),        FALSE, TRUE);
bStationEnter                         := SEL((GVL_XTS.StationCtrl[nStationSelected].Cmd = E_STATION_CTRL.STATION_MOVER_ENTER),   FALSE, TRUE);
bStationStart                         := SEL((GVL_XTS.StationCtrl[nStationSelected].Cmd = E_STATION_CTRL.STATION_PROCESS_START), FALSE, TRUE);
bStationDone                          := SEL((GVL_XTS.StationCtrl[nStationSelected].Cmd = E_STATION_CTRL.STATION_PROCESS_DONE),  FALSE, TRUE);
bStationOut                           := SEL((GVL_XTS.StationCtrl[nStationSelected].Cmd = E_STATION_CTRL.STATION_MOVER_OUT),     FALSE, TRUE);
bStationGone                          := SEL((GVL_XTS.StationCtrl[nStationSelected].Cmd = E_STATION_CTRL.STATION_MOVER_GONE),    FALSE, TRUE);

eMoverState                           := f_GetState   (GVL_XTS.MoverState[nMoverSelected].State);
eMoverResult                          := f_GetProgress(GVL_XTS.MoverState[nMoverSelected].State);

sMoverState                           := TO_STRING(eMoverState);
sMoverResult                          := TO_STRING(eMoverResult);

eSelectorState                        := f_GetState   (GVL_XTS.SelectorState.State.State);
eSelectorResult                       := f_GetProgress(GVL_XTS.SelectorState.State.State);

sSelectorState                        := TO_STRING(eSelectorState);
sSelectorResult                       := TO_STRING(eSelectorResult);

sStationState                         := TO_STRING(GVL_XTS.StationState[nStationSelected].State);
sStationStateMask                     := Tc2_Utilities.BYTE_TO_BINSTR(GVL_XTS.StationState[nStationSelected].nMask, 8);
sStationCtrlMask                      := Tc2_Utilities.BYTE_TO_BINSTR(GVL_XTS.StationCtrl[nStationSelected].nMask, 8);

tStationSelectedQueue                 := GVL_XTS.StationQueue[nStationSelected];
//############################################################################
//############################################################################

]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="MAIN">
      <LineId Id="6731" Count="409" />
      <LineId Id="6316" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.VisualizationData">
      <LineId Id="1" Count="46" />
      <LineId Id="58" Count="2" />
      <LineId Id="62" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="48" Count="9" />
    </LineIds>
  </POU>
</TcPlcObject>