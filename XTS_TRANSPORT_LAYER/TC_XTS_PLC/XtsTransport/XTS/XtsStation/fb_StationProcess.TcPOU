<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.12">
  <POU Name="fb_StationProcess" Id="{6a0a6a2b-7760-4443-be11-40a67a6801c3}" SpecialFunc="None">
    <Declaration><![CDATA[//---------------------------------------------------------------------------------------------------------------
//
//  HAUD 2025.08.27
//
//  - XTS_TRANSPORT_LAYER
//
//  fb_StationProcess extends base class
//  - handshake with extern control for mover transport through station
//  - one station one mover
//
//---------------------------------------------------------------------------------------------------------------
// This SOFTWARE is provided as an Exemple by THE PROVIDER "as is" and "with all faults." THE PROVIDER makes no 
// representations or warranties of any kind concerning the safety, suitability, lack of viruses, inaccuracies, 
// typographical errors, or other harmful components of this SOFTWARE. There are inherent dangers in the use of 
// any software, and you are solely responsible for determining whether this SOFTWARE is compatible with your 
// equipment and other software installed on your equipment. You are also solely responsible for the protection 
// of your equipment and backup of your data, and THE PROVIDER will not be liable for any damages you may suffer 
// in connection with using, modifying, or distributing this SOFTWARE.
//---------------------------------------------------------------------------------------------------------------
FUNCTION_BLOCK fb_StationProcess EXTENDS fb_StationBase
VAR
  // work vars
  _nNest,
  _nMoverDetected,
  _ix                         : UINT;
  _rModActPosFetch            : LREAL;
  _bMatchMessageLevel         : BOOL := TRUE;   // TRUE --> Mover in Station commands have equal message level as station
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="private" Id="{479c85c2-0b13-40e4-a114-57671c8eb461}" />
    <Method Name="Cycle" Id="{7ea7a6f9-8509-4d41-9999-ae04f3572e36}">
      <Declaration><![CDATA[METHOD Cycle


]]></Declaration>
      <Implementation>
        <ST><![CDATA[//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check pointer and interface
//-----------------------------------------------------------------------------
IF NOT Check() THEN RETURN; END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// set message device ID
//-----------------------------------------------------------------------------
_stMsg.eDevice                        := e_Device.XtsStation + _nStationId;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// log command change
//-----------------------------------------------------------------------------
_eCmd                                 := _stCtrl[_nStationId].eCmd;
IF (_eCmd <> _eCmdOld)
THEN
  _eCmdOld                            := _eCmd;

  _stMsg.eType                        := E_MessageType.eMessageInfo;
  _stMsg.eSubdevice                   := StationControl;
  _stMsg.iErrorNumber                 := 0;
  _stMsg.sText                        := TO_STRING(_eCmd);

  IF (_eMessageLevel > E_MessageType.eMessageWarning)
  THEN
    f_MessageSet(_stMsg);
  END_IF
END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// clear station on demand
//-----------------------------------------------------------------------------
CASE _stCtrl[_nStationId].eCmd
OF
  E_STATION_CTRL.STATION_INIT:        // commanded init from cyclic interface
    _eInitList                        := Init();
    _stState[_nStationId].rMoverModPos:= 0.0;
    _stState[_nStationId].nQueue      := TO_USINT(_ItfStation[_nStationId].Count);
    RETURN;
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// station startup and init states
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_NO_INIT:    // startup state in first PLC cycle, init linked list required
    _eInitList                        := Init();

  E_STATION_STATE.STATION_INIT:       // switch state as reserve for anything you might add here
    _stState[_nStationId].eState      := E_STATION_STATE.STATION_DISABLE;
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//  station disabled after init 
//  wait for command to enable
//  return state after a mover has left station
//  fall back state before entry was allowed and you decided to disable
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_DISABLE:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_ENABLE)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_ENABLE;
    END_IF


  E_STATION_STATE.STATION_ENABLE:     // enable state is detectable on the interface for one cycle only
                                      // double check commanded enable and clear work vars
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_ENABLE)
    THEN
      memset(ADR(_stListEnter),    0, SIZEOF(_stListEnter));

      _eStateProgress                 := E_PROGRESS.PROGRESS_INIT;  // substate for procedures within one state
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_DETECT_MOVER;  // switch to mover detection

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                  := _eMessageLevel;
        LogState(_stMsg.eType);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//  detection state
//   - wait until mover data is entered into list
//
//  check for disable command; fall back to disabled state
//  check linked list for new entry; proceed to request infeed of mover
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_DETECT_MOVER:// wait state for mover detection
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_INIT:
        IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_DISABLE) // check for commanded disable
        THEN
          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(E_STATION_STATE.STATION_DISABLE));
            f_MessageSet(_stMsg);
          END_IF
          _stState[_nStationId].eState      := E_STATION_STATE.STATION_DISABLE; // go back and wait, no matter the queue

        ELSIF (_ItfStation[_nStationId].Count > 0)
        THEN
          // someone entered something in my list
          _stListEnter                := _ItfStation[_nStationId].GetHead();
          _eStateProgress             := E_PROGRESS.PROGRESS_BUSY;  // go check list result data

          IF (_eMessageLevel > E_MessageType.eMessageWarning)
          THEN
            _stMsg.eType              := E_MessageType.eMessageInfo;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(_eStateProgress));
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_BUSY:
        IF (_stListEnter.wState = 0)  // GetHead() without error
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := e_Subdevice.StationGetHead;
          _stMsg.iErrorNumber         := _stListEnter.stData.nMoverId;
          _stMsg.sText                := '';
          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            f_MessageSet(_stMsg);
          END_IF

          // list is giving head as result
          _stMoverData                := _stListEnter.stData; // copy ticket from list result
          _eStateProgress             := E_PROGRESS.PROGRESS_PREPARE; // go check plausibility of ticket

          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(_eStateProgress));
            f_MessageSet(_stMsg);
          END_IF
        ELSE
          // the thing that must not be: GetHead() with error
          _stState[_nStationId].eState      := E_STATION_STATE.STATION_ERROR_LIST_GET_HEAD_FAULT; // fatal error

          _stMsg.eType                      := E_MessageType.eMessageError;
          LogState(_stMsg.eType);
        END_IF
    END_CASE
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_PREPARE:    // check ticket (list entry)
        // check target assignement
        IF NOT (_stMoverData.nTargetStation = _nStationId)
        THEN
          // for whom the mover calls
          // wrong address, right mover?
          _stState[_nStationId].eState      := E_STATION_STATE.STATION_ERROR_LIST_STATION_ID_WRONG; // ctrl has to fix this, go tell ctrl

          _stMsg.eType                      := E_MessageType.eMessageWarning;
          LogState(_stMsg.eType);
        ELSE
          // it's a me
          _nMoverDetected                   := _stMoverData.nMoverId;

          IF (_nMoverDetected < 1) OR
             (_nMoverDetected > MAX_MOVER)
          THEN
            // out of range the mover must not be
            _stState[_nStationId].eState    := E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID; // fatal error

            _stMsg.eType                    := E_MessageType.eMessageError;
            LogState(_stMsg.eType);
          ELSE
            memset(ADR(_stListDelete),   0, SIZEOF(_stListDelete)); // clear work var
            _eStateProgress                 := E_PROGRESS.PROGRESS_INIT; // clear progress for next station state

            // prepare station state for new mover
            _stState[_nStationId].nMoverId  := TO_USINT(_nMoverDetected); // who is waiting to enter
            _stState[_nStationId].nMask     := _stMoverData.nMask;        // how many stops have to be made
            _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_ENTER; // go ask for permission to enter

            IF (_eMessageLevel > E_MessageType.eMessageWarning)
            THEN
              _stMsg.eType            := E_MessageType.eMessageInfo;
              _stMsg.eSubdevice       := Stationstate;
              _stMsg.iErrorNumber     := _stState[_nStationId].nMoverId;
              _stMsg.sText            := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              _stMsg.sText            := concat(_stMsg.sText, TO_STRING(_eStateProgress));
              _stMsg.sText            := concat(_stMsg.sText, ': nMask: ');
              _stMsg.sText            := concat(_stMsg.sText , Tc2_Utilities.BYTE_TO_BINSTR(_stState[_nStationId].nMask, TO_INT(MAX_STATION_NEST)));
              f_MessageSet(_stMsg);
            END_IF
          END_IF
        END_IF
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// enter into station state
//  last check for disable command; fall back to disabled state
//  check for command to enter; prepare moverment, start movement
//  check for command to skip; prepare movement, switch to outfeed state
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_ENTER:          // requesting permission for mover to enter station
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_INIT:

        CASE _stCtrl[_nStationId].eCmd
        OF
          E_STATION_CTRL.STATION_DISABLE:       // control decided to disable, mover will wait
            _stState[_nStationId].eState    := E_STATION_STATE.STATION_DISABLE;

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                  := _eMessageLevel;
              LogState(_stMsg.eType);
            END_IF

          E_STATION_CTRL.STATION_MOVER_ENTER:   // control decided to let mover enter
            _nNest                    := 1;     // default PosStop[_nNest]
            _eStateProgress           := E_PROGRESS.PROGRESS_BUSY;

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType            := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice       := Stationstate;
              _stMsg.iErrorNumber     := _stState[_nStationId].nMoverId;
              _stMsg.sText            := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              _stMsg.sText            := concat(_stMsg.sText, TO_STRING(_eStateProgress));
              f_MessageSet(_stMsg);
            END_IF

            FOR _ix := 1 TO _stParameter[_nStationId].nConfiguredStopCount
            DO
              IF GetBitWord(_stMoverData.nMask, _ix-1)
              THEN
                _nNest                := _ix;
                EXIT;
              END_IF
            END_FOR

          E_STATION_CTRL.STATION_MOVER_SEND:    // control decided to send mover away
            _stOutfeed.rDistance          := _stParameter[_nStationId].rReleaseDistance;
            _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_OUT;

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                := _eMessageLevel;
              LogState(_stMsg.eType);
            END_IF
        END_CASE
    END_CASE
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_BUSY:
        MoveData();                   // prepare movement into station

        // check if infeed movement has to cross modulo turn
        _rModActPosFetch              := _Mover[_stMoverData.nMoverId].NcToPlc.ModuloActPos;

        IF (_rModActPosFetch > _stInfeed.rPos + _stParameter[_nStationId].rReleaseDistance)
        THEN
          _stInfeed.rPos              := _stInfeed.rPos + TO_REAL(_ItfMover[_stMoverData.nMoverId].RailLength);
        END_IF

        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_IN_TARGET;

        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := _eMessageLevel;
          LogState(_stMsg.eType);
        END_IF
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// move into station state
//  wait for movement to be done; mover in position and standstill
//    switch state to process handshake
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_IN_TARGET:
    _ItfMover[_stMoverData.nMoverId].MessageLevel := SEL(_bMatchMessageLevel, E_MessageType.eMessageError, _eMessageLevel);

    _Result := _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(TRUE, _stInfeed);

    IF (_Result = E_PROGRESS.PROGRESS_DONE)
    THEN
      // mother! has arrived
      _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(FALSE, _stInfeed);
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_PROCESS_START;

      IF (_eMessageLevel > E_MessageType.eMessageWarning)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        LogState(_stMsg.eType);
      END_IF
    ELSE
      IF (_Result = E_PROGRESS.PROGRESS_ERROR)
      THEN
        _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(FALSE, _stInfeed);
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_INFEED_ERROR; // ctrl has to fix this, go tell ctrl

        _stMsg.eType                  := E_MessageType.eMessageError;
        LogState(_stMsg.eType);
      END_IF 
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// process handshake state
//  clear bit in mask
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_PROCESS_START:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_PROCESS_START) OR  // double handshake, your choice
       (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_PROCESS_DONE)  OR  // single handshake, your choice
       (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT)         // quick release, mask is not checked, mover will be sent out
    THEN
      // clear bit in mask when started/done
      _stState[_nStationId].nMask     := TO_USINT(DelBitWord(TO_WORD(_stState[_nStationId].nMask), _nNest-1));
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_PROCESS_DONE;

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                  := _eMessageLevel;
        LogState(_stMsg.eType);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_PROCESS_DONE:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_PROCESS_DONE)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_CHECK;

    ELSIF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_OUT;
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check state if the mover has to move to another nest or must leave station
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_CHECK:
    IF (_stState[_nStationId].nMask = 0)
    THEN
      // mover has to leave
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_OUT;

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                  := _eMessageLevel;
        LogState(_stMsg.eType);
      END_IF
    ELSE
      // _stState[_nStationId].nMask <> 0
      FOR _ix := 1 TO MAX_STATION_NEST
      DO
        IF NOT (_ix > _stParameter[_nStationId].nConfiguredStopCount)
        THEN
          IF GetBitWord(_stState[_nStationId].nMask, _ix-1)
          THEN
            // more work to do
            _stState[_nStationId].eState  := E_STATION_STATE.STATION_CHECK_NEST;
            _nNest                        := _ix; // index to move to

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                := _eMessageLevel;
              LogState(_stMsg.eType);
            END_IF
            EXIT;
          END_IF
        ELSE
          IF GetBitWord(_stState[_nStationId].nMask, _ix-1)
          THEN
            // not configured, not worked
            _stMsg.eType              := E_MessageType.eMessageWarning;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _ix;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, Tc2_Utilities.BYTE_TO_BINSTR(_stState[_nStationId].nMask, TO_INT(MAX_STATION_NEST)));
            IF (_eMessageLevel > E_MessageType.eMessageError)
            THEN
              f_MessageSet(_stMsg);
            END_IF

            _stState[_nStationId].nMask := TO_USINT(DelBitWord(TO_WORD(_stState[_nStationId].nMask), _ix-1));
          END_IF
        END_IF
      END_FOR
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// wait state before movement to next nest has to be started
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_CHECK_NEST:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_ENTER)
    THEN
      MoveData();
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_IN_TARGET;
  
      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                  := _eMessageLevel;
        LogState(_stMsg.eType);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// wait state for outfeed of mover
//  check ctrl data, target must be plausible, nTargetStation is what you have to set
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_OUT:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT)
    THEN
      IF (_stCtrl[_nStationId].nTargetStation < 1) OR  
         (_stCtrl[_nStationId].nTargetStation > MAX_STATION)
      THEN
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_OUTFEED_TARGET_INVALID; // ctrl has to fix this, go tell ctrl

        _stMsg.eType                  := E_MessageType.eMessageError;
        LogState(_stMsg.eType);
      ELSE
        _stListDelete                 := _ItfStation[_nStationId].RemoveHeadValue(); // delete mover data in stations linked list


        IF (_stListDelete.wState <> 0)
        THEN
        // deleting mover in list was NOT successful
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_ERROR_LIST_REMOVE_HEAD_FAULT; // fatal error

          _stMsg.eType                := E_MessageType.eMessageError;
          LogState(_stMsg.eType);

        ELSE
        // mover data successfully deleted
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := e_Subdevice.StationRemoveHeadValue;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := '';
          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            f_MessageSet(_stMsg);
          END_IF

          memset(ADR(_stListTarget),   0, SIZEOF(_stListTarget)); // clear debug var

          // prepare movement and switch state to start movement
          MoverOut();
          _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_RELEASE;

          IF (_eMessageLevel > E_MessageType.eMessageWarning)
          THEN
            _stMsg.eType                := E_MessageType.eMessageInfo;
            LogState(_stMsg.eType);
          END_IF
        END_IF
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// ckeck if mover has left the station
//  enter mover data into list of target station
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_RELEASE:
    _ItfMover[_stMoverData.nMoverId].MessageLevel := SEL(_bMatchMessageLevel, E_MessageType.eMessageError, _eMessageLevel);

    _Result                           := _ItfMover[_stMoverDataSend.nMoverId].SendToModuloPosCa(TRUE, _stOutfeed);

    IF (_Result = E_PROGRESS.PROGRESS_DONE)
    THEN
      // regular outfeed
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;

    ELSIF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE) // in case outfeed has to be terminated by ctrl
    THEN
      // in order to finish the outfeed, ticket data has to be written to target station
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;

    ELSIF (_Result = E_PROGRESS.PROGRESS_ERROR)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_ERROR_OUTFEED_ERROR; // ctrl has to fix this, go tell ctrl
      _stMsg.eType                    := E_MessageType.eMessageError;
      LogState(_stMsg.eType);
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// write mover ticket in target station list
//
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_WRITE_TARGET:
    // add entry in target station list
    _stListTarget                   := _ItfStation[_stMoverDataSend.nTargetStation].AddTailValue(_stMoverDataSend);
  
    IF (_stListTarget.wState <> 0)
    THEN
    // adding mover in target list was NOT successful
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_ADD_TAIL_FAULT; // fatal error
      _stMsg.eType                  := E_MessageType.eMessageError;
      LogState(_stMsg.eType);
  
    ELSE
    // mover data successfully added to target station list
      IF (_eMessageLevel > E_MessageType.eMessageWarning)
      THEN
        _stMsg.eType                := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice           := e_Subdevice.StationAddTail;
        _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
        _stMsg.sText                := concat('TargetStation: ', TO_STRING(_stListTarget.stData.nTargetStation));
        f_MessageSet(_stMsg);
      END_IF
      _ItfMover[_stMoverDataSend.nMoverId].SendToModuloPosCa(FALSE, _stOutfeed);
  
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_GONE; // go tell ctrl that station is empty
  
      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                := _eMessageLevel;
        LogState(_stMsg.eType);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check handshake for empty station
//  switch back station state for new mover to be able to enter
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_GONE:

    memset(ADR(_stMoverData),  0, SIZEOF(_stMoverData));

    _stState[_nStationId].nMask       := 0;
    _stState[_nStationId].nMoverId    := 0;

    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_DISABLE;

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                  := _eMessageLevel;
        LogState(_stMsg.eType);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
_sState                               := TO_STRING(_stState[_nStationId].eState);
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Error handling
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_LIST_STATION_ID_WRONG:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT)
    THEN
      _nMoverDetected                 := _stMoverData.nMoverId;

      IF (_nMoverDetected < 1) OR
         (_nMoverDetected > MAX_MOVER)
      THEN
        // this MUST NOT happen
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID; // fatal error
        _stMsg.eType                  := E_MessageType.eMessageError;
        LogState(_stMsg.eType);

      ELSE
        // not for station; send mover out
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_OUT;

        IF (_eMessageLevel > E_MessageType.eMessageError)
        THEN
          _stMsg.eType                := E_MessageType.eMessageInfo;
          LogState(_stMsg.eType);
        END_IF
      END_IF

    ELSIF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_ENTER)
    THEN
      // override wrong TargetStationId in List; start infeed of mover

      _nMoverDetected                 := _stMoverData.nMoverId;

      IF (_nMoverDetected < 1) OR
         (_nMoverDetected > MAX_MOVER)
      THEN
        // this MUST NOT happen
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID; // fatal error

        _stMsg.eType                  := E_MessageType.eMessageError;
        LogState(_stMsg.eType);

      ELSE
        _eStateProgress               := E_PROGRESS.PROGRESS_INIT;
        _stState[_nStationId].nMoverId:= TO_USINT(_nMoverDetected);
        _stState[_nStationId].nMask   := _stMoverData.nMask;
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_ENTER;

        IF (_eMessageLevel > E_MessageType.eMessageError)
        THEN
          _stMsg.eType                := E_MessageType.eMessageInfo;
          LogState(_stMsg.eType);
        END_IF
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_OUTFEED_TARGET_INVALID:
    // wait here until valid target is detected
    IF NOT (_stCtrl[_nStationId].nTargetStation < 1) AND  
       NOT (_stCtrl[_nStationId].nTargetStation > MAX_STATION)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_OUT;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        LogState(_stMsg.eType);
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_INFEED_ERROR:   // must be fixed by extern by using cyclic mover control
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_ENTER_RETRY)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_DETECT_MOVER;   // return to start and wait

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        LogState(_stMsg.eType);
      END_IF
    END_IF


  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_OUTFEED_ERROR:  // must be fixed by extern by using cyclic mover control
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT_RETRY)
    THEN
      MoverOut();
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_RELEASE;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        LogState(_stMsg.eType);
      END_IF

    ELSIF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE)
    THEN
      MoverOut();

      _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                := E_MessageType.eMessageInfo;
        LogState(_stMsg.eType);
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  // fatal errors
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_LIST_GET_HEAD_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_REMOVE_HEAD_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_ADD_TAIL_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID:
    _stMsg.eType                      := E_MessageType.eMessageError;
    LogState(_stMsg.eType);
    // yes, but why?
    // cannot be fixed by ctrl
    _eFatalError                      := _stState[_nStationId].eState;
    _stState[_nStationId].eState      := E_STATION_STATE.STATION_ERROR_FATAL;
    LogState(_stMsg.eType);

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_FATAL:
    // write to string for debugging
    _sState                           := concat(TO_STRING(_stState[_nStationId].eState), ': ');
    _sState                           := concat(_sState, TO_STRING(_eFatalError));
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
IF (_stState[_nStationId].nMoverId > 0) AND
   (_stState[_nStationId].nMoverId < MAX_MOVER+1)
THEN
  _stState[_nStationId].rMoverModPos  := _Mover[_stState[_nStationId].nMoverId].NcToPlc.ModuloActPos;
ELSE
  _stState[_nStationId].rMoverModPos  := 0.0;
END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
_stState[_nStationId].nQueue          := TO_USINT(_ItfStation[_nStationId].Count);
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------]]></ST>
      </Implementation>
    </Method>
    <Method Name="LogState" Id="{8a2a3506-fb04-46f7-8f4b-c3425c424792}" FolderPath="private\">
      <Declaration><![CDATA[METHOD LogState
VAR_INPUT
  eType       : E_MessageType;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_stMsg.eType                := eType;
_stMsg.eSubdevice           := Stationstate;
_stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
_stMsg.sText                := TO_STRING(_stState[_nStationId].eState);
f_MessageSet(_stMsg);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveData" Id="{a5a3f59a-6fee-4e82-931e-bcc1715aa98a}" FolderPath="private\">
      <Declaration><![CDATA[METHOD PRIVATE MoveData // prepares movement to PostStop[_nNest] in station
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// build WorkPos from parameter, static station data and information on mover
_stInfeed.rPos            := _stParameter[_nStationId].rPosWait
                          +  _stParameter[_nStationId].rPosStop[_nNest]
                          +  _stMoverData.rOffset
                          +  _rMoverOffset[_nStationId][_stMoverData.nMoverId][_nNest];

_stInfeed.rVelo           := _stParameter[_nStationId].rVelo;
_stInfeed.rAcc            := _stParameter[_nStationId].rAccDec;
_stInfeed.rJerk           := _stParameter[_nStationId].rJerk;
_stInfeed.rGap            := _stParameter[_nStationId].rGap;
_stInfeed.rDistance       := _stParameter[_nStationId].rReleaseDistance;
_stInfeed.rDelta          := TargetWindow;

// init method
_ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(FALSE, _stInfeed);

// clear substate
_eStateProgress           := E_PROGRESS.PROGRESS_INIT;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoverOut" Id="{c53911f4-501b-436e-be79-a75f576784da}" FolderPath="private\">
      <Declaration><![CDATA[METHOD PRIVATE MoverOut // prepares mover data for sending to target station]]></Declaration>
      <Implementation>
        <ST><![CDATA[// build data for sending mover to target station

// who am I sending?
_stMoverDataSend.nMoverId         := _stState[_nStationId].nMoverId;

// get optional information about nests to work
_stMoverDataSend.nMask            := _stCtrl[_nStationId].nMask;

// get optional offset
_stMoverDataSend.rOffset          := _stCtrl[_nStationId].rOffset;

// get target station
_stMoverDataSend.nTargetStation   := _stCtrl[_nStationId].nTargetStation;

// get position of target
_stOutfeed.rPos                   := _stParameter[_stMoverDataSend.nTargetStation].rPosWait;

IF (_stOutfeed.rPos - _Mover[_stMoverDataSend.nMoverId].NcToPlc.ModuloActPos < 0)
THEN
  // only forward, never back
  _stOutfeed.rPos             := _stOutfeed.rPos 
                              +  _ItfMover[_stMoverDataSend.nMoverId].RailLength;
END_IF

_stOutfeed.rVelo              := _stParameter[_nStationId].rVelo;
_stOutfeed.rAcc               := _stParameter[_nStationId].rAccDec;
_stOutfeed.rJerk              := _stParameter[_nStationId].rJerk;
_stOutfeed.rGap               := _stParameter[_nStationId].rGap;
_stOutfeed.rDistance          := _stParameter[_nStationId].rReleaseDistance;

// init method for sending
_ItfMover[_stMoverDataSend.nMoverId].SendToModuloPosCa(FALSE, _stOutfeed);
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="fb_StationProcess">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="fb_StationProcess.Cycle">
      <LineId Id="5279" Count="744" />
      <LineId Id="4412" Count="0" />
    </LineIds>
    <LineIds Name="fb_StationProcess.LogState">
      <LineId Id="6" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="fb_StationProcess.MoveData">
      <LineId Id="21" Count="0" />
      <LineId Id="6" Count="3" />
      <LineId Id="27" Count="0" />
      <LineId Id="11" Count="3" />
      <LineId Id="29" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="15" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="fb_StationProcess.MoverOut">
      <LineId Id="41" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="6" Count="4" />
      <LineId Id="19" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="43" Count="0" />
      <LineId Id="30" Count="2" />
      <LineId Id="65" Count="4" />
      <LineId Id="64" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>