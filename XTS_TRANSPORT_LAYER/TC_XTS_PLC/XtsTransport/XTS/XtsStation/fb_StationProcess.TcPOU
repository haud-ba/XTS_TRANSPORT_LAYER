<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.13">
  <POU Name="fb_StationProcess" Id="{6a0a6a2b-7760-4443-be11-40a67a6801c3}" SpecialFunc="None">
    <Declaration><![CDATA[//---------------------------------------------------------------------------------------------------------------
//
//  HAUD 2025.08.27
//
//  - XTS_TRANSPORT_LAYER
//
//  fb_StationProcess extends base class
//  - handshake with extern control for mover transport through station
//  - one station one mover
//
//---------------------------------------------------------------------------------------------------------------
// This SOFTWARE is provided as an Exemple by THE PROVIDER "as is" and "with all faults." THE PROVIDER makes no 
// representations or warranties of any kind concerning the safety, suitability, lack of viruses, inaccuracies, 
// typographical errors, or other harmful components of this SOFTWARE. There are inherent dangers in the use of 
// any software, and you are solely responsible for determining whether this SOFTWARE is compatible with your 
// equipment and other software installed on your equipment. You are also solely responsible for the protection 
// of your equipment and backup of your data, and THE PROVIDER will not be liable for any damages you may suffer 
// in connection with using, modifying, or distributing this SOFTWARE.
//---------------------------------------------------------------------------------------------------------------
FUNCTION_BLOCK fb_StationProcess EXTENDS fb_StationBase
VAR
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Cycle" Id="{7ea7a6f9-8509-4d41-9999-ae04f3572e36}">
      <Declaration><![CDATA[METHOD Cycle


]]></Declaration>
      <Implementation>
        <ST><![CDATA[//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check pointer and interface
//-----------------------------------------------------------------------------
IF NOT Check() THEN RETURN; END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// set message device ID
//-----------------------------------------------------------------------------
_stMsg.eDevice                        := e_Device.XtsStation + _nStationId;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// log command change
//-----------------------------------------------------------------------------
_eCmd                                 := _stCtrl[_nStationId].eCmd;
IF (_eCmd <> _eCmdOld)
THEN
  _eCmdOld                            := _eCmd;

  _stMsg.eType                        := E_MessageType.eMessageInfo;
  _stMsg.eSubdevice                   := StationControl;
  _stMsg.iErrorNumber                 := 0;
  _stMsg.sText                        := TO_STRING(_eCmd);

  IF (_eMessageLevel > E_MessageType.eMessageWarning)
  THEN
    f_MessageSet(_stMsg);
  END_IF
END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// clear station on demand
//-----------------------------------------------------------------------------
CASE _stCtrl[_nStationId].eCmd
OF
  E_STATION_CTRL.STATION_INIT:        // commanded init from cyclic interface
    _eInitList                        := Init();
    _stState[_nStationId].rMoverModPos:= 0.0;
    _stState[_nStationId].nQueue      := TO_USINT(_ItfStation[_nStationId].Count);
    RETURN;
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// station startup and init states
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_NO_INIT:    // startup state in first PLC cycle, init linked list required
    _eInitList                        := Init();

  E_STATION_STATE.STATION_INIT:       // switch state as reserve for anything you might add here
    _stState[_nStationId].eState      := E_STATION_STATE.STATION_DISABLE;
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//  station disabled after init 
//  wait for command to enable
//  return state after a mover has left station
//  fall back state before entry was allowed and you decided to disable
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_DISABLE:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_ENABLE)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_ENABLE;
    END_IF


  E_STATION_STATE.STATION_ENABLE:     // enable state is detectable on the interface for one cycle only
                                      // double check commanded enable and clear work vars
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_ENABLE)
    THEN
      memset(ADR(_stListEnter),    0, SIZEOF(_stListEnter));

      _eStateProgress                 := E_PROGRESS.PROGRESS_INIT;  // substate for procedures within one state
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_DETECT_MOVER;  // switch to mover detection
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//  detection state
//   - wait until mover data is entered into list
//
//  check for disable command; fall back to disabled state
//  check linked list for new entry; proceed to request infeed of mover
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_DETECT_MOVER:// wait state for mover detection
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_INIT:
        IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_DISABLE) // check for commanded disable
        THEN
          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(E_STATION_STATE.STATION_DISABLE));
            f_MessageSet(_stMsg);
          END_IF
          _stState[_nStationId].eState      := E_STATION_STATE.STATION_DISABLE; // go back and wait, no matter the queue

        ELSIF (_ItfStation[_nStationId].Count > 0)
        THEN
          // someone entered something in my list
          _stListEnter                := _ItfStation[_nStationId].GetHead();
          _eStateProgress             := E_PROGRESS.PROGRESS_BUSY;  // go check list result data

          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := e_Subdevice.StationGetHead;
            _stMsg.iErrorNumber       := 0;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(_eStateProgress));
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_BUSY:
        IF NOT (_stListEnter.wState = 0)
        THEN
          // the thing that must not be: GetHead() with error
          _stState[_nStationId].eState    := E_STATION_STATE.STATION_ERROR_LIST_GET_HEAD_FAULT; // fatal error

        ELSE
          IF (_eMessageLevel > E_MessageType.eMessageWarning)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := e_Subdevice.StationGetHead;
            _stMsg.iErrorNumber       := _stListEnter.stData.nMoverId;
            _stMsg.sText              := '';
            f_MessageSet(_stMsg);
          END_IF
          // list is giving head as result
          _stMoverData                := _stListEnter.stData; // copy ticket from list result
          _eStateProgress             := E_PROGRESS.PROGRESS_PREPARE; // go check plausibility of ticket

          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stMoverData.nMoverId;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(_eStateProgress));
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_PREPARE:    // check ticket (list entry)
        // check target assignement
        IF (_stMoverData.nTargetStation = _nStationId)
        THEN
          _eStateProgress               := E_PROGRESS.PROGRESS_STARTUP;
        ELSE
          // for whom the mover calls
          // wrong address, right mover?
          _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_STATION_ID_WRONG; // ctrl has to fix this, go tell ctrl

          IF (_eMessageLevel > E_MessageType.eMessageEmpty)
          THEN
            _stMsg.eType                := E_MessageType.eMessageWarning;
            _stMsg.eSubdevice           := Stationstate;
            _stMsg.iErrorNumber         := _stMoverData.nTargetStation;
            _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_STARTUP:    // check ticket (list entry)
        _nMoverDetected                 := _stMoverData.nMoverId;

        IF (_nMoverDetected < 1) OR
           (_nMoverDetected > MAX_MOVER)
        THEN
          // out of range the mover must not be
          _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID; // fatal error

          _stMsg.eType                  := E_MessageType.eMessageError;
          _stMsg.eSubdevice             := Stationstate;
          _stMsg.iErrorNumber           := _stMoverData.nMoverId;
          _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);

        ELSE
          _eStateProgress               := E_PROGRESS.PROGRESS_CHECK;
        END_IF
    END_CASE
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_CHECK:      // check ticket (list entry)
        // it's a me
        memset(ADR(_stListDelete),   0, SIZEOF(_stListDelete)); // clear work var
        _eStateProgress                 := E_PROGRESS.PROGRESS_INIT; // clear progress for next station state

        // prepare station state for arriving mover
        _stState[_nStationId].nMoverId  := TO_USINT(_nMoverDetected); // who is waiting to enter
        _stState[_nStationId].nMask     := _stMoverData.nMask;        // how many stops have to be made
        _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_ENTER; // go ask for permission to enter

        IF (_eMessageLevel > E_MessageType.eMessageWarning)
        THEN
          _stMsg.eType                  := E_MessageType.eMessageInfo;
          _stMsg.eSubdevice             := Stationstate;
          _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
          _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          _stMsg.sText                  := concat(_stMsg.sText, TO_STRING(_eStateProgress));
          _stMsg.sText                  := concat(_stMsg.sText, ': nMask: ');
          _stMsg.sText                  := concat(_stMsg.sText , Tc2_Utilities.BYTE_TO_BINSTR(_stState[_nStationId].nMask, TO_INT(MAX_STATION_NEST)));
          f_MessageSet(_stMsg);

          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType                := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice           := Stationstate;
            _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
            _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText                := concat(_stMsg.sText, TO_STRING(_eStateProgress));
            _stMsg.sText                := concat(_stMsg.sText, ': _stMoverData.rOffset*1000: ');
            _stMsg.sText                := concat(_stMsg.sText , TO_STRING(TRUNC(1000.0 * _stMoverData.rOffset));
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// enter into station state
//  last check for disable command; fall back to disabled state
//  check for command to enter; prepare moverment, start movement
//  check for command to skip; prepare movement, switch to outfeed state
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_ENTER:          // requesting permission for mover to enter station
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_INIT:

        CASE _stCtrl[_nStationId].eCmd
        OF
          E_STATION_CTRL.STATION_DISABLE:       // control decided to disable, mover will wait
            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice           := Stationstate;
              _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
              _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              _stMsg.sText                := concat(_stMsg.sText, TO_STRING(E_STATION_STATE.STATION_DISABLE));
              f_MessageSet(_stMsg);
            END_IF
            _stState[_nStationId].eState  := E_STATION_STATE.STATION_DISABLE;


          E_STATION_CTRL.STATION_MOVER_ENTER:   // control decided to let mover enter
            _nNest                        := 1;     // default PosStop[_nNest]
            _eStateProgress               := E_PROGRESS.PROGRESS_BUSY;

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice           := Stationstate;
              _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
              _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              _stMsg.sText                := concat(_stMsg.sText, TO_STRING(_eStateProgress));
              f_MessageSet(_stMsg);
            END_IF

            FOR _ix := 1 TO _stParameter[_nStationId].nConfiguredStopCount
            DO
              IF BitGet(_stMoverData.nMask, _ix-1)
              THEN
                _nNest                    := _ix;
                EXIT;
              END_IF
            END_FOR

          E_STATION_CTRL.STATION_MOVER_SEND:    // control decided to send mover away
            _stOutfeed.rDistance          := _stParameter[_nStationId].rReleaseDistance;
            _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_OUT;

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice           := Stationstate;
              _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
              _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              f_MessageSet(_stMsg);
            END_IF
        END_CASE
    END_CASE
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_BUSY:
        MoveIn();                   // prepare movement into station

        // check if infeed movement has to cross modulo turn
        _rModActPosFetch              := _Mover[_stMoverData.nMoverId].NcToPlc.ModuloActPos;

        IF (_rModActPosFetch > _stInfeed.rPos + _stParameter[_nStationId].rReleaseDistance)
        THEN
          _stInfeed.rPos              := _stInfeed.rPos + TO_REAL(_ItfMover[_stMoverData.nMoverId].RailLength);
        END_IF

        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_IN_TARGET;

        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        END_IF
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// move into station state
//  wait for movement to be done; mover in position and standstill
//    switch state to process handshake
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_IN_TARGET:
    _ItfMover[_stMoverData.nMoverId].MessageLevel := SEL(_bMatchMessageLevel, E_MessageType.eMessageError, _eMessageLevel);

    _Result := _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(TRUE, _stInfeed);

    IF (_Result = E_PROGRESS.PROGRESS_DONE)
    THEN
      // mother! has arrived
      _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(FALSE, _stInfeed);
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_PROCESS_START;

      IF (_eMessageLevel > E_MessageType.eMessageWarning)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    ELSE
      IF (_Result = E_PROGRESS.PROGRESS_ERROR)
      THEN
        _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(FALSE, _stInfeed);
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_INFEED_ERROR; // ctrl has to fix this, go tell ctrl

        _stMsg.eType                  := E_MessageType.eMessageError;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF 
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// process handshake state
//  clear bit in mask
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_PROCESS_START:
    CASE _stCtrl[_nStationId].eCmd
    OF
      E_STATION_CTRL.STATION_PROCESS_START,
      E_STATION_CTRL.STATION_PROCESS_DONE,
      E_STATION_CTRL.STATION_MOVER_OUT:
        // clear bit in mask when started/done
        _stState[_nStationId].nMask   := TO_USINT(BitDel(TO_WORD(_stState[_nStationId].nMask), _nNest-1));
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_PROCESS_DONE;
  
        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        END_IF
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_PROCESS_DONE:
    CASE _stCtrl[_nStationId].eCmd
    OF
      E_STATION_CTRL.STATION_PROCESS_DONE:
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_CHECK;

      E_STATION_CTRL.STATION_MOVER_OUT:
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_OUT;
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check state if the mover has to move to another nest or must leave station
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_CHECK:
    IF (_stState[_nStationId].nMask = 0)
    THEN
      // mover has to leave
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_OUT;

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageVerbose;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    ELSE
      // _stState[_nStationId].nMask <> 0
      FOR _ix := 1 TO MAX_STATION_NEST
      DO
        IF NOT (_ix > _stParameter[_nStationId].nConfiguredStopCount)
        THEN
          IF BitGet(_stState[_nStationId].nMask, _ix-1)
          THEN
            // more work to do
            _stState[_nStationId].eState  := E_STATION_STATE.STATION_CHECK_NEST;
            _nNest                        := _ix; // index to move to

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType            := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice       := Stationstate;
              _stMsg.iErrorNumber     := _stState[_nStationId].nMoverId;
              _stMsg.sText            := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              _stMsg.sText            := concat(_stMsg.sText, ': nMask: ');
              _stMsg.sText            := concat(_stMsg.sText , Tc2_Utilities.BYTE_TO_BINSTR(_stState[_nStationId].nMask, TO_INT(MAX_STATION_NEST)));
              f_MessageSet(_stMsg);
            END_IF
            EXIT;
          END_IF
        ELSE
          IF BitGet(_stState[_nStationId].nMask, _ix-1)
          THEN
            // not configured, not worked
            _stMsg.eType              := E_MessageType.eMessageWarning;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _ix;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, Tc2_Utilities.BYTE_TO_BINSTR(_stState[_nStationId].nMask, TO_INT(MAX_STATION_NEST)));
            IF (_eMessageLevel > E_MessageType.eMessageEmpty)
            THEN
              f_MessageSet(_stMsg);
            END_IF

            _stState[_nStationId].nMask := TO_USINT(BitDel(TO_WORD(_stState[_nStationId].nMask), _ix-1));
          END_IF
        END_IF
      END_FOR
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// wait state before movement to next nest has to be started
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_CHECK_NEST:
    CASE _stCtrl[_nStationId].eCmd
    OF
      E_STATION_CTRL.STATION_MOVER_ENTER:
        MoveIn();
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_IN_TARGET;
  
        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        END_IF

      E_STATION_CTRL.STATION_PROCESS_NEST_SKIP:
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_PROCESS_START;
  
        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        END_IF

      E_STATION_CTRL.STATION_MOVER_OUT:
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_OUT;
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// wait state for outfeed of mover
//  check ctrl data, target must be plausible, nTargetStation is what you have to set
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_OUT:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT)
    THEN
      IF (_stCtrl[_nStationId].nTargetStation < 1) OR  
         (_stCtrl[_nStationId].nTargetStation > MAX_STATION)
      THEN
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_OUTFEED_TARGET_INVALID; // ctrl has to fix this, go tell ctrl

        _stMsg.eType                  := E_MessageType.eMessageError;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        _stMsg.sText                  := concat(_stMsg.sText, TO_STRING(_stCtrl[_nStationId].nTargetStation));
        f_MessageSet(_stMsg);
      ELSE
        _stListDelete                 := _ItfStation[_nStationId].RemoveHeadValue(); // delete mover data in stations linked list

        IF (_stListDelete.wState <> 0)
        THEN
        // deleting mover in list was NOT successful
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_ERROR_LIST_REMOVE_HEAD_FAULT; // fatal error

          _stMsg.eType                := E_MessageType.eMessageError;
          _stMsg.eSubdevice           := e_Subdevice.StationRemoveHeadValue;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        ELSE
        // mover data successfully deleted
          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := e_Subdevice.StationRemoveHeadValue;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := '';
            f_MessageSet(_stMsg);
          END_IF

          memset(ADR(_stListTarget),   0, SIZEOF(_stListTarget)); // clear debug var

          // prepare movement and switch state to start movement
          MoveOut();
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_MOVER_RELEASE;

          IF (_eMessageLevel > E_MessageType.eMessageWarning)
          THEN
            _stMsg.eType              := E_MessageType.eMessageInfo;
            _stMsg.eSubdevice         := e_Subdevice.StationState;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := '';
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            f_MessageSet(_stMsg);
          END_IF
        END_IF
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// ckeck if mover has left the station
//  enter mover data into list of target station
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_RELEASE:
    _ItfMover[_stMoverData.nMoverId].MessageLevel := SEL(_bMatchMessageLevel, E_MessageType.eMessageError, _eMessageLevel);

    _Result  := _ItfMover[_stMoverDataSend.nMoverId].SendToModuloPosCa(TRUE, _stOutfeed);

    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE) // in case outfeed has to be terminated by ctrl
    THEN
      // in order to finish the outfeed, ticket data has to be written to target station
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;
    ELSE
      IF (_Result = E_PROGRESS.PROGRESS_DONE)
      THEN
        // regular outfeed
        _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;
  
      ELSIF (_Result = E_PROGRESS.PROGRESS_ERROR)
      THEN
        _stState[_nStationId].eState    := E_STATION_STATE.STATION_ERROR_OUTFEED_ERROR; // ctrl has to fix this, go tell ctrl
  
        _stMsg.eType                    := E_MessageType.eMessageError;
        _stMsg.eSubdevice               := e_Subdevice.StationState;
        _stMsg.iErrorNumber             := _stState[_nStationId].nMoverId;
        _stMsg.sText                    := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF

END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// write mover ticket in target station list
//
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_WRITE_TARGET:
    // add entry in target station list
    _stListTarget                   := _ItfStation[_stMoverDataSend.nTargetStation].AddTailValue(_stMoverDataSend);
  
    IF (_stListTarget.wState <> 0)
    THEN
    // adding mover in target list was NOT successful
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_ADD_TAIL_FAULT; // fatal error

      _stMsg.eType                  := E_MessageType.eMessageError;
      _stMsg.eSubdevice             := e_Subdevice.StationAddTail;
      _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
      _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
      f_MessageSet(_stMsg);
  
    ELSE
    // mover data successfully added to target station list
      IF (_eMessageLevel > E_MessageType.eMessageWarning)
      THEN
        _stMsg.eType                := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice           := e_Subdevice.StationAddTail;
        _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
        _stMsg.sText                := concat('TargetStation: ', TO_STRING(_stListTarget.stData.nTargetStation));
        f_MessageSet(_stMsg);
      END_IF
      _ItfMover[_stMoverDataSend.nMoverId].SendToModuloPosCa(FALSE, _stOutfeed);
  
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_GONE; // go tell ctrl that station is empty
  
      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                := E_MessageType.eMessageVerbose;
        _stMsg.eSubdevice           := Stationstate;
        _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
        _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check handshake for empty station
//  switch back station state for new mover to be able to enter
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_GONE:

    memset(ADR(_stMoverData),  0, SIZEOF(_stMoverData));

    _stState[_nStationId].nMask     := 0;
    _stState[_nStationId].nMoverId  := 0;

    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE)
    THEN
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_DISABLE;

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                := E_MessageType.eMessageVerbose;
        _stMsg.eSubdevice           := Stationstate;
        _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
        _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
_sState                             := TO_STRING(_stState[_nStationId].eState);
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Error handling
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_LIST_STATION_ID_WRONG:
    CASE _stCtrl[_nStationId].eCmd
    OF
      E_STATION_CTRL.STATION_MOVER_ENTER:
        // override wrong TargetStationId in List; start infeed of mover
        _eStateProgress               := E_PROGRESS.PROGRESS_STARTUP;
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_ENTER;

      E_STATION_CTRL.STATION_MOVER_OUT:
        _nMoverDetected               := _stMoverData.nMoverId;
  
        IF (_nMoverDetected < 1) OR
           (_nMoverDetected > MAX_MOVER)
        THEN
          // this MUST NOT happen
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID; // fatal error
  
          _stMsg.eType                := E_MessageType.eMessageError;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        ELSE
          // not for station; send mover out
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_MOVER_OUT;
  
          IF (_eMessageLevel > E_MessageType.eMessageError)
          THEN
            _stMsg.eType              := E_MessageType.eMessageInfo;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE 
  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_OUTFEED_TARGET_INVALID:
    // wait here until valid target is detected
    IF NOT (_stCtrl[_nStationId].nTargetStation < 1) AND  
       NOT (_stCtrl[_nStationId].nTargetStation > MAX_STATION)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_OUT;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_INFEED_ERROR:   // must be fixed by extern by using cyclic mover control
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_ENTER_RETRY)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_DETECT_MOVER;   // return to start and wait

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_OUTFEED_ERROR:  // must be fixed by extern by using cyclic mover control
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT_RETRY)
    THEN
      MoveOut();
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_RELEASE;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF

    ELSIF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE)
    THEN
      MoveOut();

      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  // fatal errors
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_LIST_GET_HEAD_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_REMOVE_HEAD_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_ADD_TAIL_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID:
    // yes, but why?
    // cannot be fixed by ctrl
    _eFatalError                      := _stState[_nStationId].eState;
    _stState[_nStationId].eState      := E_STATION_STATE.STATION_ERROR_FATAL;

    _stMsg.eType                      := E_MessageType.eMessageError;
    _stMsg.eSubdevice                 := Stationstate;
    _stMsg.iErrorNumber               := _stState[_nStationId].nMoverId;
    _stMsg.sText                      := concat(TO_STRING(_stState[_nStationId].eState), ': ');
    _stMsg.sText                      := concat(_stMsg.sText, TO_STRING(_eFatalError));
    f_MessageSet(_stMsg);


  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_FATAL:
    // write to string for debugging
    _sState                           := concat(TO_STRING(_stState[_nStationId].eState), ': ');
    _sState                           := concat(_sState, TO_STRING(_eFatalError));
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
IF (_stState[_nStationId].nMoverId > 0) AND
   (_stState[_nStationId].nMoverId < MAX_MOVER+1)
THEN
  _stState[_nStationId].rMoverModPos  := _Mover[_stState[_nStationId].nMoverId].NcToPlc.ModuloActPos;
ELSE
  _stState[_nStationId].rMoverModPos  := 0.0;
END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
_stState[_nStationId].nQueue          := TO_USINT(_ItfStation[_nStationId].Count);
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="fb_StationProcess">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="fb_StationProcess.Cycle">
      <LineId Id="5279" Count="76" />
      <LineId Id="5362" Count="12" />
      <LineId Id="6339" Count="0" />
      <LineId Id="5375" Count="32" />
      <LineId Id="6340" Count="0" />
      <LineId Id="5408" Count="4" />
      <LineId Id="6337" Count="1" />
      <LineId Id="6423" Count="0" />
      <LineId Id="6336" Count="0" />
      <LineId Id="5417" Count="1" />
      <LineId Id="6025" Count="3" />
      <LineId Id="5419" Count="1" />
      <LineId Id="5422" Count="12" />
      <LineId Id="5441" Count="1" />
      <LineId Id="6341" Count="0" />
      <LineId Id="5443" Count="5" />
      <LineId Id="6345" Count="1" />
      <LineId Id="5449" Count="2" />
      <LineId Id="6030" Count="6" />
      <LineId Id="6038" Count="1" />
      <LineId Id="5488" Count="0" />
      <LineId Id="6315" Count="0" />
      <LineId Id="6342" Count="0" />
      <LineId Id="6316" Count="2" />
      <LineId Id="6320" Count="15" />
      <LineId Id="6319" Count="0" />
      <LineId Id="5489" Count="0" />
      <LineId Id="6343" Count="0" />
      <LineId Id="6234" Count="2" />
      <LineId Id="6238" Count="0" />
      <LineId Id="6254" Count="17" />
      <LineId Id="6434" Count="0" />
      <LineId Id="6425" Count="0" />
      <LineId Id="6435" Count="0" />
      <LineId Id="6426" Count="7" />
      <LineId Id="6436" Count="0" />
      <LineId Id="6272" Count="0" />
      <LineId Id="6233" Count="0" />
      <LineId Id="5490" Count="17" />
      <LineId Id="6048" Count="8" />
      <LineId Id="5508" Count="1" />
      <LineId Id="5515" Count="29" />
      <LineId Id="6057" Count="3" />
      <LineId Id="6062" Count="0" />
      <LineId Id="5547" Count="19" />
      <LineId Id="6063" Count="4" />
      <LineId Id="5569" Count="24" />
      <LineId Id="6068" Count="3" />
      <LineId Id="5595" Count="7" />
      <LineId Id="6072" Count="3" />
      <LineId Id="5604" Count="10" />
      <LineId Id="6347" Count="1" />
      <LineId Id="6351" Count="2" />
      <LineId Id="6355" Count="11" />
      <LineId Id="6349" Count="0" />
      <LineId Id="5629" Count="5" />
      <LineId Id="6368" Count="1" />
      <LineId Id="6371" Count="0" />
      <LineId Id="6386" Count="1" />
      <LineId Id="6372" Count="0" />
      <LineId Id="6388" Count="0" />
      <LineId Id="6385" Count="0" />
      <LineId Id="5643" Count="14" />
      <LineId Id="6081" Count="4" />
      <LineId Id="5660" Count="14" />
      <LineId Id="6086" Count="6" />
      <LineId Id="5677" Count="29" />
      <LineId Id="6390" Count="2" />
      <LineId Id="6398" Count="10" />
      <LineId Id="6410" Count="0" />
      <LineId Id="6409" Count="0" />
      <LineId Id="6411" Count="1" />
      <LineId Id="6421" Count="0" />
      <LineId Id="6414" Count="6" />
      <LineId Id="6394" Count="3" />
      <LineId Id="5718" Count="16" />
      <LineId Id="6107" Count="2" />
      <LineId Id="6111" Count="0" />
      <LineId Id="6110" Count="0" />
      <LineId Id="5736" Count="2" />
      <LineId Id="5740" Count="4" />
      <LineId Id="6112" Count="3" />
      <LineId Id="6117" Count="0" />
      <LineId Id="5748" Count="1" />
      <LineId Id="5754" Count="1" />
      <LineId Id="6119" Count="3" />
      <LineId Id="5756" Count="11" />
      <LineId Id="6124" Count="2" />
      <LineId Id="6128" Count="0" />
      <LineId Id="6127" Count="0" />
      <LineId Id="5769" Count="15" />
      <LineId Id="6129" Count="2" />
      <LineId Id="6136" Count="1" />
      <LineId Id="6132" Count="0" />
      <LineId Id="6146" Count="14" />
      <LineId Id="6134" Count="0" />
      <LineId Id="5785" Count="0" />
      <LineId Id="5802" Count="15" />
      <LineId Id="6166" Count="0" />
      <LineId Id="6161" Count="4" />
      <LineId Id="5820" Count="16" />
      <LineId Id="6167" Count="4" />
      <LineId Id="5839" Count="22" />
      <LineId Id="6172" Count="4" />
      <LineId Id="5864" Count="14" />
      <LineId Id="6278" Count="0" />
      <LineId Id="6280" Count="0" />
      <LineId Id="6282" Count="0" />
      <LineId Id="6284" Count="3" />
      <LineId Id="6283" Count="0" />
      <LineId Id="6289" Count="25" />
      <LineId Id="6281" Count="0" />
      <LineId Id="5931" Count="10" />
      <LineId Id="6199" Count="4" />
      <LineId Id="5944" Count="11" />
      <LineId Id="6204" Count="4" />
      <LineId Id="5958" Count="1" />
      <LineId Id="5961" Count="10" />
      <LineId Id="6209" Count="4" />
      <LineId Id="5974" Count="9" />
      <LineId Id="6214" Count="4" />
      <LineId Id="5986" Count="9" />
      <LineId Id="6229" Count="1" />
      <LineId Id="6232" Count="0" />
      <LineId Id="6231" Count="0" />
      <LineId Id="6226" Count="0" />
      <LineId Id="6219" Count="3" />
      <LineId Id="6224" Count="0" />
      <LineId Id="6223" Count="0" />
      <LineId Id="6227" Count="0" />
      <LineId Id="6003" Count="20" />
      <LineId Id="4412" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>