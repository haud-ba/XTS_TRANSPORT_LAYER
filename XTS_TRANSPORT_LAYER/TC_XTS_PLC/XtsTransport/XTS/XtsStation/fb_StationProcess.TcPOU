<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.13">
  <POU Name="fb_StationProcess" Id="{6a0a6a2b-7760-4443-be11-40a67a6801c3}" SpecialFunc="None">
    <Declaration><![CDATA[//---------------------------------------------------------------------------------------------------------------
//
//  HAUD 2025.08.21
//
//  - XTS_TRANSPORT_LAYER
//
//  fb_Station
//  - extends fb_StationBase
//  - handshake with extern control for mover transport through station
//  - one station one mover
//
//---------------------------------------------------------------------------------------------------------------
// This SOFTWARE is provided as an Exemple by THE PROVIDER "as is" and "with all faults." THE PROVIDER makes no 
// representations or warranties of any kind concerning the safety, suitability, lack of viruses, inaccuracies, 
// typographical errors, or other harmful components of this SOFTWARE. There are inherent dangers in the use of 
// any software, and you are solely responsible for determining whether this SOFTWARE is compatible with your 
// equipment and other software installed on your equipment. You are also solely responsible for the protection 
// of your equipment and backup of your data, and THE PROVIDER will not be liable for any damages you may suffer 
// in connection with using, modifying, or distributing this SOFTWARE.
//---------------------------------------------------------------------------------------------------------------
FUNCTION_BLOCK fb_StationProcess EXTENDS fb_StationBase
VAR
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Cycle" Id="{7ea7a6f9-8509-4d41-9999-ae04f3572e36}">
      <Declaration><![CDATA[METHOD Cycle


]]></Declaration>
      <Implementation>
        <ST><![CDATA[//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check pointer and interface
//-----------------------------------------------------------------------------
IF NOT Check() THEN RETURN; END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// set message device ID
//-----------------------------------------------------------------------------
_stMsg.eDevice                        := e_Device.XtsStation + _nStationId;
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// log command change
//-----------------------------------------------------------------------------
_eCmd                                 := _stCtrl[_nStationId].eCmd;
IF (_eCmd <> _eCmdOld)
THEN
  _eCmdOld                            := _eCmd;

  _stMsg.eType                        := E_MessageType.eMessageInfo;
  _stMsg.eSubdevice                   := StationControl;
  _stMsg.iErrorNumber                 := 0;
  _stMsg.sText                        := TO_STRING(_eCmd);

  IF (_eMessageLevel > E_MessageType.eMessageWarning)
  THEN
    f_MessageSet(_stMsg);
  END_IF
END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// clear station on demand
//-----------------------------------------------------------------------------
CASE _stCtrl[_nStationId].eCmd
OF
  E_STATION_CTRL.STATION_INIT:        // commanded init from cyclic interface
    _eInitList                        := Init();
    _stState[_nStationId].rMoverModPos:= 0.0;
    _stState[_nStationId].nQueue      := TO_USINT(_ItfStation[_nStationId].Count);
    RETURN;
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// station startup and init states
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_NO_INIT:    // startup state in first PLC cycle, init linked list required
    _eInitList                        := Init();

  E_STATION_STATE.STATION_INIT:       // switch state as reserve for anything you might add here
    _stState[_nStationId].eState      := E_STATION_STATE.STATION_DISABLE;
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//  station disabled after init 
//  wait for command to enable
//  return state after a mover has left station
//  fall back state before entry was allowed and you decided to disable
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_DISABLE:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_ENABLE)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_ENABLE;
    END_IF


  E_STATION_STATE.STATION_ENABLE:     // enable state is detectable on the interface for one cycle only
                                      // double check commanded enable and clear work vars
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_ENABLE)
    THEN
      memset(ADR(_stListEnter),    0, SIZEOF(_stListEnter));

      _eStateProgress                 := E_PROGRESS.PROGRESS_INIT;  // substate for procedures within one state
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_DETECT_MOVER;  // switch to mover detection

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                  := _eMessageLevel;
        LogState(_stMsg.eType);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//  detection state
//   - wait until mover data is entered into list
//
//  check for disable command; fall back to disabled state
//  check linked list for new entry; proceed to request infeed of mover
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_DETECT_MOVER:// wait state for mover detection
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_INIT:
        IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_DISABLE) // check for commanded disable
        THEN
          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(E_STATION_STATE.STATION_DISABLE));
            f_MessageSet(_stMsg);
          END_IF
          _stState[_nStationId].eState      := E_STATION_STATE.STATION_DISABLE; // go back and wait, no matter the queue

        ELSIF (_ItfStation[_nStationId].Count > 0)
        THEN
          // someone entered something in my list
          _stListEnter                := _ItfStation[_nStationId].GetHead();
          _eStateProgress             := E_PROGRESS.PROGRESS_BUSY;  // go check list result data

          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := e_Subdevice.StationGetHead;
            _stMsg.iErrorNumber       := 0;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(_eStateProgress));
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_BUSY:
        IF NOT (_stListEnter.wState = 0)
        THEN
          // the thing that must not be: GetHead() with error
          _stState[_nStationId].eState    := E_STATION_STATE.STATION_ERROR_LIST_GET_HEAD_FAULT; // fatal error

        ELSE
          IF (_eMessageLevel > E_MessageType.eMessageWarning)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := e_Subdevice.StationGetHead;
            _stMsg.iErrorNumber       := _stListEnter.stData.nMoverId;
            _stMsg.sText              := '';
            f_MessageSet(_stMsg);
          END_IF
          // list is giving head as result
          _stMoverData                := _stListEnter.stData; // copy ticket from list result
          _eStateProgress             := E_PROGRESS.PROGRESS_PREPARE; // go check plausibility of ticket

          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stMoverData.nMoverId;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, TO_STRING(_eStateProgress));
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_PREPARE:    // check ticket (list entry)
        // check target assignement
        IF (_stMoverData.nTargetStation = _nStationId)
        THEN
          _eStateProgress               := E_PROGRESS.PROGRESS_STARTUP;
        ELSE
          // for whom the mover calls
          // wrong address, right mover?
          _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_STATION_ID_WRONG; // ctrl has to fix this, go tell ctrl

          IF (_eMessageLevel > E_MessageType.eMessageEmpty)
          THEN
            _stMsg.eType                := E_MessageType.eMessageWarning;
            _stMsg.eSubdevice           := Stationstate;
            _stMsg.iErrorNumber         := _stMoverData.nTargetStation;
            _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_STARTUP:    // check ticket (list entry)
        _nMoverDetected                 := _stMoverData.nMoverId;

        IF (_nMoverDetected < 1) OR
           (_nMoverDetected > MAX_MOVER)
        THEN
          // out of range the mover must not be
          _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID; // fatal error

          _stMsg.eType                  := E_MessageType.eMessageError;
          _stMsg.eSubdevice             := Stationstate;
          _stMsg.iErrorNumber           := _stMoverData.nMoverId;
          _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);

        ELSE
          _eStateProgress               := E_PROGRESS.PROGRESS_CHECK;
        END_IF
    END_CASE
    //-------------------------------------------------------------------------
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_CHECK:      // check ticket (list entry)
        // it's a me
        memset(ADR(_stListDelete),   0, SIZEOF(_stListDelete)); // clear work var
        _eStateProgress                 := E_PROGRESS.PROGRESS_INIT; // clear progress for next station state

        // prepare station state for arriving mover
        _stState[_nStationId].nMoverId  := TO_USINT(_nMoverDetected); // who is waiting to enter
        _stState[_nStationId].nMask     := _stMoverData.nMask;        // how many stops have to be made
        _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_ENTER; // go ask for permission to enter

        IF (_eMessageLevel > E_MessageType.eMessageWarning)
        THEN
          _stMsg.eType                  := E_MessageType.eMessageInfo;
          _stMsg.eSubdevice             := Stationstate;
          _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
          _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          _stMsg.sText                  := concat(_stMsg.sText, TO_STRING(_eStateProgress));
          _stMsg.sText                  := concat(_stMsg.sText, ': nMask: ');
          _stMsg.sText                  := concat(_stMsg.sText , Tc2_Utilities.BYTE_TO_BINSTR(_stState[_nStationId].nMask, TO_INT(MAX_STATION_NEST)));
          f_MessageSet(_stMsg);

          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType                := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice           := Stationstate;
            _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
            _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText                := concat(_stMsg.sText, TO_STRING(_eStateProgress));
            _stMsg.sText                := concat(_stMsg.sText, ': _stMoverData.rOffset*1000: ');
            _stMsg.sText                := concat(_stMsg.sText , TO_STRING(TRUNC(1000.0 * _stMoverData.rOffset)));
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// enter into station state
//  last check for disable command; fall back to disabled state
//  check for command to enter; prepare moverment, start movement
//  check for command to skip; prepare movement, switch to outfeed state
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_ENTER:          // requesting permission for mover to enter station
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_INIT:

        CASE _stCtrl[_nStationId].eCmd
        OF
          E_STATION_CTRL.STATION_DISABLE:       // control decided to disable, mover will wait
            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice           := Stationstate;
              _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
              _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              _stMsg.sText                := concat(_stMsg.sText, TO_STRING(E_STATION_STATE.STATION_DISABLE));
              f_MessageSet(_stMsg);
            END_IF
            _stState[_nStationId].eState  := E_STATION_STATE.STATION_DISABLE;


          E_STATION_CTRL.STATION_MOVER_ENTER:   // control decided to let mover enter
            _nNest                        := 1;     // default PosStop[_nNest]
            _eStateProgress               := E_PROGRESS.PROGRESS_BUSY;

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice           := Stationstate;
              _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
              _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              _stMsg.sText                := concat(_stMsg.sText, TO_STRING(_eStateProgress));
              f_MessageSet(_stMsg);
            END_IF

            FOR _ix := 1 TO _stParameter[_nStationId].nConfiguredStopCount
            DO
              IF BitGet(_stMoverData.nMask, _ix-1)
              THEN
                _nNest                    := _ix;
                EXIT;
              END_IF
            END_FOR

          E_STATION_CTRL.STATION_MOVER_SEND:    // control decided to send mover away
            _stOutfeed.rDistance          := _stParameter[_nStationId].rReleaseDistance;
            _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_OUT;

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType                := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice           := Stationstate;
              _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
              _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              f_MessageSet(_stMsg);
            END_IF
        END_CASE
    END_CASE
    CASE _eStateProgress
    OF
      E_PROGRESS.PROGRESS_BUSY:
        MoveIn();                   // prepare movement into station

        // check if infeed movement has to cross modulo turn
        _rModActPosFetch              := _Mover[_stMoverData.nMoverId].NcToPlc.ModuloActPos;

        IF (_rModActPosFetch > _stInfeed.rPos + _stParameter[_nStationId].rReleaseDistance)
        THEN
          _stInfeed.rPos              := _stInfeed.rPos + TO_REAL(_ItfMover[_stMoverData.nMoverId].RailLength);
        END_IF

        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_IN_TARGET;

        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        END_IF
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// move into station state
//  wait for movement to be done; mover in position and standstill
//    switch state to process handshake
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_IN_TARGET:
    _ItfMover[_stMoverData.nMoverId].MessageLevel := SEL(_bMatchMessageLevel, E_MessageType.eMessageError, _eMessageLevel);

    _Result := _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(TRUE, _stInfeed);

    IF (_Result = E_PROGRESS.PROGRESS_DONE)
    THEN
      // mother! has arrived
      _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(FALSE, _stInfeed);
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_PROCESS_START;

      IF (_eMessageLevel > E_MessageType.eMessageWarning)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    ELSE
      IF (_Result = E_PROGRESS.PROGRESS_ERROR)
      THEN
        _ItfMover[_stState[_nStationId].nMoverId].MoveToPosCa(FALSE, _stInfeed);
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_INFEED_ERROR; // ctrl has to fix this, go tell ctrl

        _stMsg.eType                  := E_MessageType.eMessageError;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF 
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// process handshake state
//  clear bit in mask
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_PROCESS_START:
    CASE _stCtrl[_nStationId].eCmd
    OF
      E_STATION_CTRL.STATION_PROCESS_START,
      E_STATION_CTRL.STATION_PROCESS_DONE,
      E_STATION_CTRL.STATION_MOVER_OUT:
        // clear bit in mask when started/done
        _stState[_nStationId].nMask   := TO_USINT(BitDel(TO_WORD(_stState[_nStationId].nMask), _nNest-1));
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_PROCESS_DONE;
  
        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        END_IF
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_PROCESS_DONE:
    CASE _stCtrl[_nStationId].eCmd
    OF
      E_STATION_CTRL.STATION_PROCESS_DONE:
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_CHECK;

      E_STATION_CTRL.STATION_MOVER_OUT:
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_OUT;
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check state if the mover has to move to another nest or must leave station
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_CHECK:
    IF (_stState[_nStationId].nMask = 0)
    THEN
      // mover has to leave
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_OUT;

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageVerbose;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    ELSE
      // _stState[_nStationId].nMask <> 0
      FOR _ix := 1 TO MAX_STATION_NEST
      DO
        IF NOT (_ix > _stParameter[_nStationId].nConfiguredStopCount)
        THEN
          IF BitGet(_stState[_nStationId].nMask, _ix-1)
          THEN
            // more work to do
            _stState[_nStationId].eState  := E_STATION_STATE.STATION_CHECK_NEST;
            _nNest                        := _ix; // index to move to

            IF (_eMessageLevel = E_MessageType.eMessageVerbose)
            THEN
              _stMsg.eType            := E_MessageType.eMessageVerbose;
              _stMsg.eSubdevice       := Stationstate;
              _stMsg.iErrorNumber     := _stState[_nStationId].nMoverId;
              _stMsg.sText            := concat(TO_STRING(_stState[_nStationId].eState), ': ');
              _stMsg.sText            := concat(_stMsg.sText, ': nMask: ');
              _stMsg.sText            := concat(_stMsg.sText , Tc2_Utilities.BYTE_TO_BINSTR(_stState[_nStationId].nMask, TO_INT(MAX_STATION_NEST)));
              f_MessageSet(_stMsg);
            END_IF
            EXIT;
          END_IF
        ELSE
          IF BitGet(_stState[_nStationId].nMask, _ix-1)
          THEN
            // not configured, not worked
            _stMsg.eType              := E_MessageType.eMessageWarning;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _ix;
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            _stMsg.sText              := concat(_stMsg.sText, Tc2_Utilities.BYTE_TO_BINSTR(_stState[_nStationId].nMask, TO_INT(MAX_STATION_NEST)));
            IF (_eMessageLevel > E_MessageType.eMessageEmpty)
            THEN
              f_MessageSet(_stMsg);
            END_IF

            _stState[_nStationId].nMask := TO_USINT(BitDel(TO_WORD(_stState[_nStationId].nMask), _ix-1));
          END_IF
        END_IF
      END_FOR
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// wait state before movement to next nest has to be started
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_CHECK_NEST:
    CASE _stCtrl[_nStationId].eCmd
    OF
      E_STATION_CTRL.STATION_MOVER_ENTER:
        MoveIn();
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_IN_TARGET;
  
        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        END_IF

      E_STATION_CTRL.STATION_PROCESS_NEST_SKIP:
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_PROCESS_START;
  
        IF (_eMessageLevel = E_MessageType.eMessageVerbose)
        THEN
          _stMsg.eType                := E_MessageType.eMessageVerbose;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        END_IF

      E_STATION_CTRL.STATION_MOVER_OUT:
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_OUT;
    END_CASE
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// wait state for outfeed of mover
//  check ctrl data, target must be plausible, nTargetStation is what you have to set
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_OUT:
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT)
    THEN
      IF (_stCtrl[_nStationId].nTargetStation < 1) OR  
         (_stCtrl[_nStationId].nTargetStation > MAX_STATION)
      THEN
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_OUTFEED_TARGET_INVALID; // ctrl has to fix this, go tell ctrl

        _stMsg.eType                  := E_MessageType.eMessageError;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        _stMsg.sText                  := concat(_stMsg.sText, TO_STRING(_stCtrl[_nStationId].nTargetStation));
        f_MessageSet(_stMsg);
      ELSE
        _stListDelete                 := _ItfStation[_nStationId].RemoveHeadValue(); // delete mover data in stations linked list

        IF (_stListDelete.wState <> 0)
        THEN
        // deleting mover in list was NOT successful
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_ERROR_LIST_REMOVE_HEAD_FAULT; // fatal error

          _stMsg.eType                := E_MessageType.eMessageError;
          _stMsg.eSubdevice           := e_Subdevice.StationRemoveHeadValue;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        ELSE
        // mover data successfully deleted
          IF (_eMessageLevel = E_MessageType.eMessageVerbose)
          THEN
            _stMsg.eType              := E_MessageType.eMessageVerbose;
            _stMsg.eSubdevice         := e_Subdevice.StationRemoveHeadValue;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := '';
            f_MessageSet(_stMsg);
          END_IF

          memset(ADR(_stListTarget),   0, SIZEOF(_stListTarget)); // clear debug var

          // prepare movement and switch state to start movement
          MoveOut();
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_MOVER_RELEASE;

          IF (_eMessageLevel > E_MessageType.eMessageWarning)
          THEN
            _stMsg.eType              := E_MessageType.eMessageInfo;
            _stMsg.eSubdevice         := e_Subdevice.StationState;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText              := '';
            _stMsg.sText              := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            f_MessageSet(_stMsg);
          END_IF
        END_IF
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// ckeck if mover has left the station
//  enter mover data into list of target station
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_RELEASE:
    _ItfMover[_stMoverData.nMoverId].MessageLevel := SEL(_bMatchMessageLevel, E_MessageType.eMessageError, _eMessageLevel);

    _Result  := _ItfMover[_stMoverDataSend.nMoverId].SendToModuloPosCa(TRUE, _stOutfeed);

    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE) // in case outfeed has to be terminated by ctrl
    THEN
      // in order to finish the outfeed, ticket data has to be written to target station
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;
    ELSE
      IF (_Result = E_PROGRESS.PROGRESS_DONE)
      THEN
        // regular outfeed
        _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;
  
      ELSIF (_Result = E_PROGRESS.PROGRESS_ERROR)
      THEN
        _stState[_nStationId].eState    := E_STATION_STATE.STATION_ERROR_OUTFEED_ERROR; // ctrl has to fix this, go tell ctrl
  
        _stMsg.eType                    := E_MessageType.eMessageError;
        _stMsg.eSubdevice               := e_Subdevice.StationState;
        _stMsg.iErrorNumber             := _stState[_nStationId].nMoverId;
        _stMsg.sText                    := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF

END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// write mover ticket in target station list
//
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_WRITE_TARGET:
    // add entry in target station list
    _stListTarget                   := _ItfStation[_stMoverDataSend.nTargetStation].AddTailValue(_stMoverDataSend);
  
    IF (_stListTarget.wState <> 0)
    THEN
    // adding mover in target list was NOT successful
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_ERROR_LIST_ADD_TAIL_FAULT; // fatal error

      _stMsg.eType                  := E_MessageType.eMessageError;
      _stMsg.eSubdevice             := e_Subdevice.StationAddTail;
      _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
      _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
      f_MessageSet(_stMsg);
  
    ELSE
    // mover data successfully added to target station list
      IF (_eMessageLevel > E_MessageType.eMessageWarning)
      THEN
        _stMsg.eType                := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice           := e_Subdevice.StationAddTail;
        _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
        _stMsg.sText                := concat('TargetStation: ', TO_STRING(_stListTarget.stData.nTargetStation));
        f_MessageSet(_stMsg);
      END_IF
      _ItfMover[_stMoverDataSend.nMoverId].SendToModuloPosCa(FALSE, _stOutfeed);
  
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_GONE; // go tell ctrl that station is empty
  
      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                := E_MessageType.eMessageVerbose;
        _stMsg.eSubdevice           := Stationstate;
        _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
        _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// check handshake for empty station
//  switch back station state for new mover to be able to enter
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  E_STATION_STATE.STATION_MOVER_GONE:

    memset(ADR(_stMoverData),  0, SIZEOF(_stMoverData));

    _stState[_nStationId].nMask     := 0;
    _stState[_nStationId].nMoverId  := 0;

    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE)
    THEN
      _stState[_nStationId].eState  := E_STATION_STATE.STATION_DISABLE;

      IF (_eMessageLevel = E_MessageType.eMessageVerbose)
      THEN
        _stMsg.eType                := E_MessageType.eMessageVerbose;
        _stMsg.eSubdevice           := Stationstate;
        _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
        _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
_sState                             := TO_STRING(_stState[_nStationId].eState);
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Error handling
//-----------------------------------------------------------------------------
CASE _stState[_nStationId].eState
OF
  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_LIST_STATION_ID_WRONG:
    CASE _stCtrl[_nStationId].eCmd
    OF
      E_STATION_CTRL.STATION_MOVER_ENTER:
        // override wrong TargetStationId in List; start infeed of mover
        _eStateProgress               := E_PROGRESS.PROGRESS_STARTUP;
        _stState[_nStationId].eState  := E_STATION_STATE.STATION_MOVER_ENTER;

      E_STATION_CTRL.STATION_MOVER_OUT:
        _nMoverDetected               := _stMoverData.nMoverId;
  
        IF (_nMoverDetected < 1) OR
           (_nMoverDetected > MAX_MOVER)
        THEN
          // this MUST NOT happen
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID; // fatal error
  
          _stMsg.eType                := E_MessageType.eMessageError;
          _stMsg.eSubdevice           := Stationstate;
          _stMsg.iErrorNumber         := _stState[_nStationId].nMoverId;
          _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
          f_MessageSet(_stMsg);
        ELSE
          // not for station; send mover out
          _stState[_nStationId].eState:= E_STATION_STATE.STATION_MOVER_OUT;
  
          IF (_eMessageLevel > E_MessageType.eMessageError)
          THEN
            _stMsg.eType              := E_MessageType.eMessageInfo;
            _stMsg.eSubdevice         := Stationstate;
            _stMsg.iErrorNumber       := _stState[_nStationId].nMoverId;
            _stMsg.sText                := concat(TO_STRING(_stState[_nStationId].eState), ': ');
            f_MessageSet(_stMsg);
          END_IF
        END_IF
    END_CASE 
  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_OUTFEED_TARGET_INVALID:
    // wait here until valid target is detected
    IF NOT (_stCtrl[_nStationId].nTargetStation < 1) AND  
       NOT (_stCtrl[_nStationId].nTargetStation > MAX_STATION)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_OUT;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_INFEED_ERROR:   // must be fixed by extern by using cyclic mover control
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_ENTER_RETRY)
    THEN
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_DETECT_MOVER;   // return to start and wait

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_OUTFEED_ERROR:  // must be fixed by extern by using cyclic mover control
    IF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_OUT_RETRY)
    THEN
      MoveOut();
      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_RELEASE;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF

    ELSIF (_stCtrl[_nStationId].eCmd = E_STATION_CTRL.STATION_MOVER_GONE)
    THEN
      MoveOut();

      _stState[_nStationId].eState    := E_STATION_STATE.STATION_MOVER_WRITE_TARGET;

      IF (_eMessageLevel > E_MessageType.eMessageError)
      THEN
        _stMsg.eType                  := E_MessageType.eMessageInfo;
        _stMsg.eSubdevice             := Stationstate;
        _stMsg.iErrorNumber           := _stState[_nStationId].nMoverId;
        _stMsg.sText                  := concat(TO_STRING(_stState[_nStationId].eState), ': ');
        f_MessageSet(_stMsg);
      END_IF
    END_IF

  //---------------------------------------------------------------------------
  // fatal errors
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_LIST_GET_HEAD_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_REMOVE_HEAD_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_ADD_TAIL_FAULT,
  E_STATION_STATE.STATION_ERROR_LIST_MOVER_ID_INVALID:
    // yes, but why?
    // cannot be fixed by ctrl
    _eFatalError                      := _stState[_nStationId].eState;
    _stState[_nStationId].eState      := E_STATION_STATE.STATION_ERROR_FATAL;

    _stMsg.eType                      := E_MessageType.eMessageError;
    _stMsg.eSubdevice                 := Stationstate;
    _stMsg.iErrorNumber               := _stState[_nStationId].nMoverId;
    _stMsg.sText                      := concat(TO_STRING(_stState[_nStationId].eState), ': ');
    _stMsg.sText                      := concat(_stMsg.sText, TO_STRING(_eFatalError));
    f_MessageSet(_stMsg);


  //---------------------------------------------------------------------------
  //---------------------------------------------------------------------------
  E_STATION_STATE.STATION_ERROR_FATAL:
    // write to string for debugging
    _sState                           := concat(TO_STRING(_stState[_nStationId].eState), ': ');
    _sState                           := concat(_sState, TO_STRING(_eFatalError));
END_CASE
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
IF (_stState[_nStationId].nMoverId > 0) AND
   (_stState[_nStationId].nMoverId < MAX_MOVER+1)
THEN
  _stState[_nStationId].rMoverModPos  := _Mover[_stState[_nStationId].nMoverId].NcToPlc.ModuloActPos;
ELSE
  _stState[_nStationId].rMoverModPos  := 0.0;
END_IF
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
_stState[_nStationId].nQueue          := TO_USINT(_ItfStation[_nStationId].Count);
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="fb_StationProcess">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="fb_StationProcess.Cycle">
      <LineId Id="6437" Count="849" />
      <LineId Id="4412" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>