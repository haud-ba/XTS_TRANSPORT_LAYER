<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_SimpleCaExample" Id="{a1ceff41-774c-4e59-af4a-f7f398040a2b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SimpleCaExample
//---------------------------------------------------------------------------------------------------------------
//
//  Fen 2023.12.21
//
//  XTS_TRAINING
//  - example project for setting up transport layer
//
//
//  FB_SimpleCaExample
//  - Sequence for moving on an XTS-System with CA
//  - 
//
//
//---------------------------------------------------------------------------------------------------------------
// This SOFTWARE is provided as an Exemple by THE PROVIDER "as is" and "with all faults." THE PROVIDER makes no 
// representations or warranties of any kind concerning the safety, suitability, lack of viruses, inaccuracies, 
// typographical errors, or other harmful components of this SOFTWARE. There are inherent dangers in the use of 
// any software, and you are solely responsible for determining whether this SOFTWARE is compatible with your 
// equipment and other software installed on your equipment. You are also solely responsible for the protection 
// of your equipment and backup of your data, and THE PROVIDER will not be liable for any damages you may suffer 
// in connection with using, modifying, or distributing this SOFTWARE.
//---------------------------------------------------------------------------------------------------------------
VAR_INPUT
	ipMover				: ARRAY [1..MAX_MOVER] OF I_Mover;
	ipCaGroup			: I_CaGroup;
END_VAR

VAR
	stVisuIO			: ST_VisuExampleIO;
	fbOpmStateMachine	: FB_OperatingMode;
	
	fbWaitTime			: TON;
	nWaitTime			: INT := 1000;
	
	
	btest				: BOOL;
	sActOpmState		: STRING;

END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[// simple Example to move in Ca-Mode


// CA State to Visu
	IF ipCaGroup <> 0 THEN
		stVisuIO.stCaGroup REF= ipCaGroup.GroupRef;
	END_IF	


// Xts Operating Mode

	// Opm Handler
		fbOpmStateMachine.Command := stVisuIO.eStateCommand;
	
		fbOpmStateMachine.Cyclic();
		
		stVisuIO.eStateCommand := fbOpmStateMachine.Command ;
		
		stVisuIO.eOPMState := fbOpmStateMachine.eState;
		stVisuIO.eLastOPMState := fbOpmStateMachine.eLastState;
		
		sActOpmState := fbOpmStateMachine.sState;

	// States
	CASE fbOpmStateMachine.eState OF
	E_OperatingState.OperatingMode_INVALID :
			M_Clear(FALSE);
			M_Prepare(FALSE);
			M_Stopping(FALSE);
			M_Home(FALSE);
			M_Active(FALSE);
			M_Empty(FALSE);
			M_Reset(FALSE);
	
	E_OperatingState.OperatingMode_Clear :
		IF NOT M_Clear(TRUE) THEN
			M_Clear(FALSE);
			fbOpmStateMachine.M_StateComplete();
		END_IF
		
			M_Prepare(FALSE);
			M_Stopping(FALSE);
			M_Home(FALSE);
			M_Active(FALSE);
			M_Empty(FALSE);
			M_Reset(FALSE);

	E_OperatingState.OperatingMode_Prepare :
		IF NOT M_Prepare(TRUE) THEN
			M_Prepare(FALSE);
			fbOpmStateMachine.M_StateComplete();
		END_IF
		
			M_Stopping(FALSE);
			M_Home(FALSE);
			M_Active(FALSE);
			M_Empty(FALSE);
			M_Reset(FALSE);
	
	E_OperatingState.OperatingMode_Stopping :
		IF NOT M_Stopping(TRUE) THEN
			M_Stopping(FALSE);
			fbOpmStateMachine.M_StateComplete();
		END_IF

			M_Prepare(FALSE);
			M_Home(FALSE);
			M_Active(FALSE);
			M_Empty(FALSE);
			M_Reset(FALSE);
		
	E_OperatingState.OperatingMode_Home :
		IF NOT M_Home(TRUE) THEN
			M_Home(FALSE);
			fbOpmStateMachine.M_StateComplete();
		END_IF
		

	E_OperatingState.OperatingMode_Active :
		IF NOT M_Active(TRUE) THEN
			M_Active(FALSE);
			fbOpmStateMachine.M_StateComplete();
		END_IF

	E_OperatingState.OperatingMode_Empty :
		IF NOT M_Empty(TRUE) THEN
			M_Empty(FALSE);
			fbOpmStateMachine.M_StateComplete();
		END_IF

	E_OperatingState.OperatingMode_Reset :
		IF NOT M_Reset(TRUE) THEN
			M_Reset(FALSE);
			fbOpmStateMachine.M_StateComplete();
		END_IF
		
		
	ELSE	
		;
	END_CASE
	












//	CASE stVisuIO.eOPMState OF
//	
//	// Invalid 	--> wait for Cmd 	
//	E_OperatingState.OperatingMode_INVALID : 
//		IF stVisuIO.eStateCommand = E_OperatingCmd.OperatingCmd_Clear THEN
//			stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//			stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_INVALID;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//		END_IF
//		
//	// Clear 	--> Init Ca-Group  and Axis 	
//	E_OperatingState.OperatingMode_Clear:
//		IF NOT M_Clear(TRUE) THEN
//			M_Clear(FALSE);
//			stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear_Sc;
//		END_IF
//		
//		CASE stVisuIO.eStateCommand	OF  			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Clear;
//			
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//				
//		END_CASE
//		
//	// Clear_Sc 	--> State complete	
//	E_OperatingState.OperatingMode_Clear_Sc :
//		CASE stVisuIO.eStateCommand	OF  
//			E_OperatingCmd.OperatingCmd_Clear :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Clear_Sc;
//			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Clear_Sc;
//				
//			E_OperatingCmd.OperatingCmd_Prepare	:
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Prepare;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Clear_Sc;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//				
//		END_CASE
//		
//		M_Clear(FALSE);	
//	
//	// Prepare 	--> build Ca-Group  and enable Axis 	
//	E_OperatingState.OperatingMode_Prepare :
//		IF NOT M_Prepare(TRUE) THEN
//			M_Prepare(FALSE);
//			stVisuIO.eOPMState := E_OperatingState.OperatingMode_Prepar_Sc;
//		END_IF
//		
//		CASE stVisuIO.eStateCommand	OF  
//			E_OperatingCmd.OperatingCmd_Clear :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Prepare;
//				M_Prepare(FALSE);
//			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Prepare;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//		END_CASE
//	
//	// Stopping 	--> stop Axis 		
//	E_OperatingState.OperatingMode_Stopping :
//		IF NOT M_Stopping(TRUE) THEN
//			M_Stopping(FALSE);
//			stVisuIO.eOPMState := E_OperatingState.OperatingMode_Prepar_Sc;
//		END_IF
//		
//		CASE stVisuIO.eStateCommand	OF  
//			E_OperatingCmd.OperatingCmd_Clear :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Stopping;
//				M_Stopping(FALSE);
//			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Stopping;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//		END_CASE
//		
//	// Prepare 	--> emptying the system 		
//	E_OperatingState.OperatingMode_Empty:
//		IF NOT M_Empty(TRUE) THEN
//			M_Empty(FALSE);
//			stVisuIO.eOPMState := E_OperatingState.OperatingMode_Prepar_Sc;
//		END_IF
//		
//		CASE stVisuIO.eStateCommand	OF  
//			E_OperatingCmd.OperatingCmd_Clear :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Empty;
//				M_Empty(FALSE);
//			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Empty;
//				
//			E_OperatingCmd.OperatingCmd_Stopping :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Stopping;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Empty;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//			
//		END_CASE
//	
//	// 	Prepare 	--> State complete
//	E_OperatingState.OperatingMode_Prepar_Sc:
//		CASE stVisuIO.eStateCommand	OF  
//			E_OperatingCmd.OperatingCmd_Clear :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Prepar_Sc;
//			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Prepar_Sc;
//				
//			E_OperatingCmd.OperatingCmd_Stopping :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Stopping;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Prepar_Sc;
//			
//			E_OperatingCmd.OperatingCmd_Home 	:
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Home;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Prepar_Sc;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//	
//		END_CASE
//	
//	// 	Home 	--> Move to Start Position
//	E_OperatingState.OperatingMode_Home :
//		IF NOT M_Home(TRUE) THEN
//			M_Home(FALSE);
//			stVisuIO.eOPMState := E_OperatingState.OperatingMode_Home_Sc;
//		END_IF
//		
//		CASE stVisuIO.eStateCommand	OF  
//			E_OperatingCmd.OperatingCmd_Clear :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Home;
//			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Home;
//				
//			E_OperatingCmd.OperatingCmd_Stopping :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Stopping;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Home;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//	
//		END_CASE
//	
//	// 	Home 	--> State complete
//	E_OperatingState.OperatingMode_Home_Sc :	
//		stVisuIO.eOPMState := E_OperatingState.OperatingMode_Active;
//		
//		CASE stVisuIO.eStateCommand	OF  
//			E_OperatingCmd.OperatingCmd_Clear :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Home_Sc;
//			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Home_Sc;
//				
//			E_OperatingCmd.OperatingCmd_Stopping :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Stopping;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Home_Sc;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//	
//		END_CASE
//	
//	// 	Active/Work 	--> execute work sequences
// 	E_OperatingState.OperatingMode_Active :
//		CASE stVisuIO.eStateCommand	OF  
//			E_OperatingCmd.OperatingCmd_Clear :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Clear;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Active;
//			
//			E_OperatingCmd.OperatingCmd_Reset :	
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Reset;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Active;
//				
//			E_OperatingCmd.OperatingCmd_Stopping :
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Stopping;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Active;
//			
//			E_OperatingCmd.OperatingCmd_Empty 	:
//				stVisuIO.eOPMState := E_OperatingState.OperatingMode_Empty;
//				stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//				stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Active;
//		
//		ELSE 
//			stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;	
//				
//		END_CASE
//	
//	// 	Reset 	--> Reset Error --> Jump to last state back
//	E_OperatingState.OperatingMode_Reset :
//		;
//	
//		stVisuIO.eStateCommand := E_OperatingCmd.OperatingCmd_DONE;
//		IF btest THEN
//			btest := FALSE;
//			stVisuIO.eOPMState := stVisuIO.eLastOPMState;
//			stVisuIO.eLastOPMState := E_OperatingState.OperatingMode_Reset;
//		END_IF
//	
//	END_CASE
]]></ST>
    </Implementation>
    <Method Name="M_Active" Id="{f14a9a93-ace1-4c59-b051-d148981e504e}">
      <Declaration><![CDATA[METHOD M_Active : BOOL  // Busy
VAR_INPUT
	Execute		: BOOL;
END_VAR

VAR_INST
	_iState					: INT;
	_bBusy					: BOOL;
	fbWaitTime				: ton;  

	fbWaitTimeAtPos			: ARRAY[0..3] OF ton;
	xLeadMoverPos			: ARRAY[0..3] OF BOOL;   
	nLeadMoverPos			: ARRAY[0..3] OF INT;


	_iSequencCount	: INT;
	
	_xTest			: BOOL;

END_VAR

VAR 
	i 						: UINT;
	nIdx					: INT;
	fAbsStartPos			: LREAL;
	
	fLeadMoverPos 			: LREAL;
	xAllMoverStandStill 	: BOOL;

	

	
	stMoveData_Clear	: ST_MOVE_DATA;
	stMoveData_Halt		: ST_MOVE_DATA;
	stMoveData			: ST_MOVE_DATA;

	stMoverInfo				: ST_MOVER_INFO;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Running Sequence   
(*
	- Clear Command
	- do the Machinesequence
	
for example
	// detect LeadMover at Pos1
	// detect LeadMover at Pos2
	// detect LeadMover at Pos3
	// Send from SetPos1 the leading movers to SetPos2
	// Send from SetPos2 the leading movers to SetPos3 
	// Send from SetPos3 the leading movers to SetPos1 	
*)

IF NOT Execute THEN
	M_Active := TRUE;
	_iState := 0;
	_bBusy := FALSE;
	fbWaitTime(IN:= FALSE);
	FOR i:= 1 TO 3 DO
		fbWaitTimeAtPos[i](IN:= FALSE, PT:= T#1S);
	END_FOR
	RETURN;
END_IF


	IF ((_iState < 0) AND NOT _xTest)	
		OR (_iState > 100)	
		OR (_iState = 100 AND NOT _bBusy) 
	THEN
		_iState := 0;
		_bBusy := FALSE;
		
		fbWaitTime(IN:= FALSE);
		FOR i:= 1 TO 3 DO
			fbWaitTimeAtPos[i](IN:= FALSE, PT:= T#1S);
		END_FOR
		
		xAllMoverStandStill := FALSE;
		
	END_IF

	
	CASE _iState OF
	0:	// idel
		
		IF not Execute THEN
			;
		ELSE
			_bBusy := TRUE;
			_iState := 10;
		END_IF
	
	10:	// Clear Command	
		_bBusy := TRUE;
	
		stMoveData_Clear.rPos := 0;
		stMoveData_Clear.rVelo := 0;
		stMoveData_Clear.rAcc := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rJerk := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rGap := 100;
		stMoveData_Clear.rOverride := 100;
		stMoveData_Clear.rDelta := 0;
		stMoveData_Clear.rDistance := 0;
		
		//ClearCmd to Mover  -->   For Loop 	ipMover
		FOR i := 1 TO MAX_MOVER DO
			ipMover[i].Disable(FALSE);
			ipMover[i].Enable(FALSE);
			//ipMover[i].GearIn(FALSE,);
			//ipMover[i].GearInPosCa(FALSE,);
			ipMover[i].GearOut(FALSE);
			ipMover[i].Halt(FALSE, stMoveData_Clear);
			ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			ipMover[i].Reset(FALSE);
			ipMover[i].SendToPosCa(FALSE,stMoveData_Clear);
		END_FOR
		
		// ClearCmd to Ca-Group					ipCaGroup					
		ipCaGroup.AddAll(FALSE);
		ipCaGroup.Disable(FALSE);
		ipCaGroup.Enable(FALSE);
		ipCaGroup.McHaltAll(FALSE);
		ipCaGroup.McResetAll(FALSE);
		ipCaGroup.RemoveAll(FALSE);
		ipCaGroup.Reset(FALSE);

		
		_iState := 20;
		IF _xTest THEN
			_iState := _iState * -1;
		END_IF
		
	20: //Send from SetPos1 the leading movers to SetPos2
		//Send from SetPos2 the leading movers to SetPos3 
		//Send from SetPos3 the leading movers to SetPos1 

		// detect LeadMover at Pos1 (window +- 1)
			nIdx:= 1;
			xLeadMoverPos[nIdx] := FALSE;
			nLeadMoverPos[nIdx] := -1;
			FOR i:= 1 TO MAX_MOVER DO
			
				stMoverInfo := ipMover[i].GetMoverInfo();	
			
				IF stMoverInfo.bMoverStandstill 
					AND stMoverInfo.rModuloActPos < stVisuIO.fSetPos1 +1 		// +/- 1
					AND stMoverInfo.rModuloActPos >	stVisuIO.fSetPos1 -1 	// +/- 1
				THEN	
					xLeadMoverPos[nIdx] := TRUE;
					nLeadMoverPos[nIdx] := TO_INT(i);
					
					
				//	ipMover[nIdx].MoveToPosCa(FALSE, stMoveData_Clear);
					
					EXIT;
				END_IF		 	
			END_FOR
		
		// detect LeadMover at Pos2 (window +- 1)
			nIdx:= 2;
			xLeadMoverPos[nIdx] := FALSE;
			nLeadMoverPos[nIdx] := -1;
			FOR i:= 1 TO MAX_MOVER DO
			
				stMoverInfo := ipMover[i].GetMoverInfo();	
			
				IF stMoverInfo.bMoverStandstill 
					AND stMoverInfo.rModuloActPos < stVisuIO.fSetPos2 +1 		// +/- 1
					AND stMoverInfo.rModuloActPos >	stVisuIO.fSetPos2 -1 	// +/- 1
				THEN	
					xLeadMoverPos[nIdx] := TRUE;
					nLeadMoverPos[nIdx] := TO_INT(i);
					
					
				//	ipMover[nIdx].MoveToPosCa(FALSE, stMoveData_Clear);
					
					EXIT;
				END_IF		 	
			END_FOR

		// detect LeadMover at Pos3 (window +- 1)
			nIdx:= 3;
			xLeadMoverPos[nIdx] := FALSE;
			nLeadMoverPos[nIdx] := -1;
			FOR i:= 1 TO MAX_MOVER DO
			
				stMoverInfo := ipMover[i].GetMoverInfo();	
			
				IF stMoverInfo.bMoverStandstill 
					AND stMoverInfo.rModuloActPos < stVisuIO.fSetPos3 +1 		// +/- 1
					AND stMoverInfo.rModuloActPos >	stVisuIO.fSetPos3 -1 	// +/- 1
				THEN	
					xLeadMoverPos[nIdx] := TRUE;
					nLeadMoverPos[nIdx] := TO_INT(i);
					
					
				//	ipMover[nIdx].MoveToPosCa(FALSE, stMoveData_Clear);
					
					EXIT;
				END_IF		 	
			END_FOR

		// delayTime at Pos X
			FOR i:= 1 TO 3 DO
				fbWaitTimeAtPos[i](IN:= xLeadMoverPos[i], PT:= T#1.2S);
			END_FOR



		// Position 1 -------------------------------------------------
		// Start Lead Mover to Pos2
		nIdx :=nLeadMoverPos[1];
		
		IF (nLeadMoverPos[1] > 0 AND nLeadMoverPos[1] <= TO_INT(MAX_MOVER)) 			// Lead Mover valid
		AND fbWaitTimeatPos[1].Q														// Delay Time
		AND stVisuIO.bAgain																// Again from Visu
		AND xLeadMoverPos[1]															// LeadMover found
		AND (	ipCaGroup.GroupInfo.GroupMoving 		// MC_GROUP_STATE.mcGroupStateMoving	// Ca-Group Moving
				OR ipCaGroup.GroupInfo.GroupStandby) 	// MC_GROUP_STATE.mcGroupStateStandby	// Ca-Group StandBy
		THEN
			stMoverInfo := ipMover[nIdx].GetMoverInfo();
			
			IF stMoverInfo.bMoverStandstill
				AND NOT stMoverInfo.bMoverAvoidingCollision	
			THEN			// Mover is not Busy	
	
				stMoveData.rPos := 			stVisuIO.fSetPos2;
				stMoveData.rVelo := 		1800;
				stMoveData.rAcc := 			Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rJerk := 		Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rGap := 			150; 
				stMoveData.rOverride := 	100;
				stMoveData.rDelta := 		1;
				stMoveData.rDistance := 	0;

				//Execute- Pos 1->2
				IF ipMover[nIdx].MoveToPosCa(FALSE, stMoveData) = E_PROGRESS.PROGRESS_INIT THEN
					ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);
				END_IF
				
				
				//ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);


			END_IF 
		END_IF

		// Position 2 -------------------------------------------------
		// Start Lead Mover to Pos3
		nIdx :=nLeadMoverPos[2];
	
		IF (nLeadMoverPos[2] > 0 AND nLeadMoverPos[2] <= TO_INT(MAX_MOVER))
		AND fbWaitTimeatPos[2].Q		
		AND stVisuIO.bAgain		
		AND xLeadMoverPos[2]																	// LeadMover found
		AND (	ipCaGroup.GroupInfo.GroupMoving 		// MC_GROUP_STATE.mcGroupStateMoving	// Ca-Group Moving
				OR ipCaGroup.GroupInfo.GroupStandby) 	// MC_GROUP_STATE.mcGroupStateStandby	// Ca-Group StandBy
		THEN
			stMoverInfo := ipMover[nIdx].GetMoverInfo();
			
			IF stMoverInfo.bMoverStandstill
				AND NOT stMoverInfo.bMoverAvoidingCollision	
			THEN			// Mover is not Busy	
	
				stMoveData.rPos := 			stVisuIO.fSetPos3;
				stMoveData.rVelo := 		1500;
				stMoveData.rAcc := 			Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rJerk := 		Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rGap := 			100; 
				stMoveData.rOverride := 	100;
				stMoveData.rDelta := 		1;
				stMoveData.rDistance := 	0;
			
				//Execute- Pos 2->3
				IF ipMover[nIdx].MoveToPosCa(FALSE, stMoveData) = E_PROGRESS.PROGRESS_INIT THEN
					ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);
				END_IF
				
				//ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);

			END_IF	
		END_IF	

		// Position 3 -------------------------------------------------
		// Start Lead Mover to Pos1
		nIdx :=nLeadMoverPos[3];	
	
		IF (nLeadMoverPos[3] > 0 AND nLeadMoverPos[3] <= TO_INT(MAX_MOVER))
		AND fbWaitTimeatPos[3].Q		
		AND stVisuIO.bAgain		
		AND xLeadMoverPos[3]																	// LeadMover found
		AND (	ipCaGroup.GroupInfo.GroupMoving 		// MC_GROUP_STATE.mcGroupStateMoving	// Ca-Group Moving
				OR ipCaGroup.GroupInfo.GroupStandby) 	// MC_GROUP_STATE.mcGroupStateStandby	// Ca-Group StandBy
		THEN
			stMoverInfo := ipMover[nIdx].GetMoverInfo();
			
			IF stMoverInfo.bMoverStandstill
				AND NOT stMoverInfo.bMoverAvoidingCollision	
			THEN			// Mover is not Busy	
	
				stMoveData.rPos := 			stVisuIO.fSetPos1;
				stMoveData.rVelo := 		3000;
				stMoveData.rAcc := 			Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rJerk := 		Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rGap := 			100; (*66*)
				stMoveData.rOverride := 	100;
				stMoveData.rDelta := 		1;
				stMoveData.rDistance := 	0;
				
				//Execute- Pos 3->1
				IF ipMover[nIdx].MoveToPosCa(FALSE, stMoveData) = E_PROGRESS.PROGRESS_INIT THEN
					ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);
				END_IF
				
				//ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);

			END_IF
		END_IF	
		
		
		
		// Check standstill		
		xAllMoverStandStill := TRUE;
		FOR i:= 1 TO MAX_MOVER DO
			stMoverInfo := ipMover[i].GetMoverInfo();
			xAllMoverStandStill := 
				xAllMoverStandStill
				AND stMoverInfo.bMoverStandstill ;
		END_FOR
		
		IF NOT stVisuIO.bAgain 
		AND xAllMoverStandStill	THEN
			FOR i:= 1 TO MAX_MOVER DO
				
				ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			
			END_FOR
			_iState := 99;
		END_IF	


	
	
	99: // Internal
		_iState := 100; 
		_iSequencCount := _iSequencCount +1; 
			
	
	100: // Done
		_bBusy := FALSE;	
		

	
	END_CASE

	// ReturnValue
	M_Active := _bBusy;
	
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Clear" Id="{a83172e0-14df-4d16-b49c-412896aaae0c}">
      <Declaration><![CDATA[METHOD M_Clear : BOOL  // Busy
VAR_INPUT
	Execute		: BOOL;
END_VAR

VAR_INST
	_iState				: INT;
	_bBusy				: BOOL;
	_iSequencCount		: INT;
	_xTest				: BOOL := FALSE;
END_VAR

VAR 
	i					: UINT;
	xHaltCaDone			: BOOL;
	xAllMoversDisabled	: BOOL;

	xAllAxisReset		: BOOL;
	
	stMoveData_Clear	: ST_MOVE_DATA;
	stMoveData_Halt		: ST_MOVE_DATA;
	stMoveData_Move		: ST_MOVE_DATA;
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Abborting Sequence
(*
	-! Clear Command
	- Reset Ca-Group
	- Halt-Command to Mover
	- Disable Ca-Group
	- Ungroupo all Mover
	- Disable Axis
*)

IF NOT Execute THEN
	M_Clear := TRUE;
	_iState := 0;
	_bBusy := FALSE;
	
	RETURN;
END_IF

	IF ((_iState < 0) AND NOT _xTest)	
		OR (_iState > 100)	
		OR (_iState = 100 AND NOT _bBusy) 
		OR (NOT Execute)
	THEN
		_iState := 0;
		_bBusy := FALSE;
	END_IF

	
	CASE _iState OF
	0:	// idel
		
		IF NOT Execute THEN
			;
		ELSE
			_bBusy := TRUE;
			_iState := 10;
		END_IF
	
	10:	// Clear Command	
		_bBusy := TRUE;
	
		stMoveData_Clear.rPos := 0;
		stMoveData_Clear.rVelo := 0;
		stMoveData_Clear.rAcc := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rJerk := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rGap := 100;
		stMoveData_Clear.rOverride := 100;
		stMoveData_Clear.rDelta := 0;
		stMoveData_Clear.rDistance := 0;
		
		//ClearCmd to Mover  -->   For Loop 	ipMover
		FOR i := 1 TO MAX_MOVER DO
			ipMover[i].Disable(FALSE);
			ipMover[i].Enable(FALSE);
			//ipMover[i].GearIn(FALSE,);
			//ipMover[i].GearInPosCa(FALSE,);
			ipMover[i].GearOut(FALSE);
			ipMover[i].Halt(FALSE, stMoveData_Clear);
			ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			ipMover[i].Reset(FALSE);
			ipMover[i].SendToPosCa(FALSE,stMoveData_Clear);
		END_FOR
		
		// ClearCmd to Ca-Group					ipCaGroup					
		ipCaGroup.AddAll(FALSE);
		ipCaGroup.Disable(FALSE);
		ipCaGroup.Enable(FALSE);
		ipCaGroup.McHaltAll(FALSE);
		ipCaGroup.McResetAll(FALSE);
		ipCaGroup.RemoveAll(FALSE);
		ipCaGroup.Reset(FALSE);


		
		
		_iState := 20;
		IF _xTest THEN
			_iState := _iState * -1;
		END_IF
		
		
	20: // Reset Ca-Group if is necessary
		(* 
		## check with ipCaGroup.P_CaGroupState 	& MC_GROUP_STATE
		## use ipCaGroup.CaGroupReset()
		*)
		IF ipCaGroup.GroupInfo.GroupErrorStop	  THEN
			IF ipCaGroup.Reset(TRUE) = E_PROGRESS.PROGRESS_DONE THEN
				ipCaGroup.Reset(FALSE);
				_iState := 30;
			END_IF
		ELSE
			_iState := 30;	
			IF _xTest THEN
				_iState := _iState * -1;
			END_IF
		END_IF


	
	30: // Halt-Command to Mover
		(*
		## use ipMover[i].stInHaltCaMover
		## check with ipMover[i].P_Halt.Done OR ipMover[i].P_HaltCa.Done	or 
		## check with ipMover[i].P_SetVelocity = 0	
		*);

		stMoveData_Halt.rAcc 	:= MC_DEFAULT;
		stMoveData_Halt.rJerk 	:= MC_DEFAULT;	
		stMoveData_Halt.rGap 	:= 75.0;
		
	
		
		FOR i:= 1 TO MAX_MOVER DO
			xHaltCaDone := 
					xHaltCaDone
					AND  ipMover[i].Halt(TRUE, stMoveData_Halt) = E_PROGRESS.PROGRESS_DONE;		
			//HaltCmd('Aborting', stHaltParameter);
		END_FOR
		
		_iState := _iState +1 ;
		IF _xTest THEN
			_iState := _iState * -1;
		END_IF
		
	31:	// HaldCmd Done	
		(*
		## check with ipMover[i].P_Halt.Done OR ipMover[i].P_HaltCa.Done	or 
		## check with ipMover[i].P_SetVelocity = 0	
		*)
		
		xHaltCaDone:= TRUE;
		// check is done in State 30

		// Clear HaltCa-Command	
		IF xHaltCaDone THEN	
			_iState := 50;
			IF _xTest THEN
				_iState := _iState * -1;
			END_IF
		END_IF
		
		
	50:	// Disable Ca-Group 
		(*
		## check with ipCaGroup.P_CaGroupState & MC_GROUP_STATE	 
		## use ipCaGroup.CaGroupReset()
		## use ipCaGroup.DisableGroup()
		*);
		
		// Reset Group
		IF ipCaGroup.GroupInfo.GroupErrorStop (*MC_GROUP_STATE.mcGroupStateErrorStop*) THEN
			_iState := _iState + 1;
		
		// Disable Group	
		ELSIF NOT ipCaGroup.GroupInfo.GroupDisabled (*MC_GROUP_STATE.mcGroupStateDisabled*)	THEN
			_iState := _iState + 2;
		
		// GoOn	
		ELSIF ipCaGroup.GroupInfo.GroupDisabled (*MC_GROUP_STATE.mcGroupStateDisabled*) THEN
			_iState := 60;	
			IF _xTest THEN
				_iState := _iState * -1;
			END_IF
		END_IF
		
	51:	// Reset CA-Group
		IF ipCaGroup.Reset(TRUE) = E_PROGRESS.PROGRESS_DONE THEN
			ipCaGroup.Reset(FALSE);
			_iState := 50;
		END_IF
			
	52:	// Disable CA-Group
		IF ipCaGroup.Disable(TRUE) = E_PROGRESS.PROGRESS_DONE THEN
			ipCaGroup.Disable(FALSE);
			_iState := 50;
		END_IF			
			
	
	
	60:	// Ungroupo all Mover
		(*
		## check with ipCaGroup.P_CountAxisInGroup <> 0
		## use ipCaGroup.UngroupAllAxes()		
		*);
		
		IF ipCaGroup.GroupInfo.AxisCount <> 0 THEN
			
			// Ungroup all Axis
			CASE ipCaGroup.RemoveAll(TRUE)	OF
  				E_PROGRESS.PROGRESS_DONE :
					ipCaGroup.RemoveAll(FALSE);
					_iState := 70;
				E_PROGRESS.PROGRESS_ERROR :
					; // Error Handler	
			END_CASE
		
		ELSE 
			_iState := 70;
			IF _xTest THEN
				_iState := _iState * -1;
			END_IF
			
			FOR i := 1 TO MAX_MOVER DO
				ipMover[i].Disable(FALSE);
			END_FOR
		END_IF 	
		
		
	70:	// Disable Axis
	
		(*
		## use ipMover[i].PowerOff()
		## check with ipMover[i].PowerOff()						
		*);
		
		xAllMoversDisabled:= TRUE;
		FOR i := 1 TO MAX_MOVER DO
			xAllMoversDisabled :=
				xAllMoversDisabled 
				AND (ipMover[i].Disable(TRUE) = E_PROGRESS.PROGRESS_DONE );
		END_FOR
		
		
		IF xAllMoversDisabled THEN
			FOR i := 1 TO MAX_MOVER DO
				ipMover[i].Disable(FALSE);
			END_FOR
			_iState := 99;		
		END_IF

	99:	// Internal
		_iState := 100;
		_iSequencCount := _iSequencCount +1;
		
	100: // Done
		_bBusy := FALSE;	
		


	END_CASE

	// ReturnValue
	M_Clear:= _bBusy;
	
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Empty" Id="{4b1386a6-ba2e-4b10-afac-a127801352cc}">
      <Declaration><![CDATA[METHOD M_Empty : BOOL  // Busy
VAR_INPUT
	Execute		: BOOL;
END_VAR

VAR_INST
	_iState					: INT;
	_bBusy					: BOOL;

	fbWaitTime				: ton;  
	fbWaitTimeAtPos			: ARRAY[0..3] OF ton;
	xLeadMoverPos			: ARRAY[0..3] OF BOOL;   
	nLeadMoverPos			: ARRAY[0..3] OF INT;


	_iSequencCount	: INT;
	
	

END_VAR

VAR 
	i						: uint;
	nIdx					: INT;
	fAbsStartPos			: LREAL;
	
	fLeadMoverPos 			: LREAL;

	
	
	xAllMoverStandStill 	: BOOL;

	
	stInMoveAbsCaMover		: INT;
	
	stMoveData_Clear		: ST_MOVE_DATA;
	stMoveData				: ST_MOVE_DATA;
	stMoverInfo				: ST_MOVER_INFO;
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Completing Sequence
(*
	- Clear Command
	- do the Stoppingsequence
	
for example
	// detect LeadMover at Pos1
	// detect LeadMover at Pos2
	// detect LeadMover at Pos3
	// Wait at Pos1
	// Send from SetPos2 the leading movers to SetPos3 
	// Send from SetPos3 the leading movers to SetPos1 	

*)

IF NOT Execute THEN
	M_Empty := TRUE;
	_iState := 0;
	_bBusy := FALSE;
	
	RETURN;
END_IF

	IF (_iState < 0)	
		OR (_iState > 100)	
		OR (_iState = 100 AND NOT _bBusy) 
		OR (NOT Execute)
	THEN
		_iState := 0;
		_bBusy := FALSE;
	END_IF

	
	CASE _iState OF
	0:	// idel
		
		IF NOT Execute THEN
			;
		ELSE
			_bBusy := TRUE;
			_iState := 10;
		END_IF
	
	10:	// Clear Command	
		_bBusy := TRUE;
	
		stMoveData_Clear.rPos := 0;
		stMoveData_Clear.rVelo := 0;
		stMoveData_Clear.rAcc := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rJerk := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rGap := 100;
		stMoveData_Clear.rOverride := 100;
		stMoveData_Clear.rDelta := 0;
		stMoveData_Clear.rDistance := 0;
		
		//ClearCmd to Mover  -->   For Loop 	ipMover
		FOR i := 1 TO MAX_MOVER DO
			ipMover[i].Disable(FALSE);
			ipMover[i].Enable(FALSE);
			//ipMover[i].GearIn(FALSE,);
			//ipMover[i].GearInPosCa(FALSE,);
			ipMover[i].GearOut(FALSE);
			ipMover[i].Halt(FALSE, stMoveData_Clear);
			ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			ipMover[i].Reset(FALSE);
			ipMover[i].SendToPosCa(FALSE,stMoveData_Clear);
		END_FOR
		
		// ClearCmd to Ca-Group					ipCaGroup					
		ipCaGroup.AddAll(FALSE);
		ipCaGroup.Disable(FALSE);
		ipCaGroup.Enable(FALSE);
		ipCaGroup.McHaltAll(FALSE);
		ipCaGroup.McResetAll(FALSE);
		ipCaGroup.RemoveAll(FALSE);
		ipCaGroup.Reset(FALSE);


		stVisuIO.bAgain := FALSE;
		
		_iState := 20;
		
	20: //Send from SetPos1 the leading movers to SetPos2
		//Send from SetPos2 the leading movers to SetPos3 
		//Send from SetPos3 the leading movers to SetPos1 

		// detect LeadMover at Pos1 (window +- 1)
			nIdx:= 1;
			xLeadMoverPos[nIdx] := FALSE;
			nLeadMoverPos[nIdx] := -1;
			FOR i:= 1 TO MAX_MOVER DO
			
				stMoverInfo := ipMover[i].GetMoverInfo();	
			
				IF stMoverInfo.bMoverStandstill 
					AND stMoverInfo.rModuloActPos < stVisuIO.fSetPos1 +1 		// +/- 1
					AND stMoverInfo.rModuloActPos >	stVisuIO.fSetPos1 -1 	// +/- 1
				THEN	
					xLeadMoverPos[nIdx] := TRUE;
					nLeadMoverPos[nIdx] := TO_INT(i);
					
					
				//	ipMover[nIdx].MoveToPosCa(FALSE, stMoveData_Clear);
					
					EXIT;
				END_IF		 	
			END_FOR
		
		// detect LeadMover at Pos2 (window +- 1)
			nIdx:= 2;
			xLeadMoverPos[nIdx] := FALSE;
			nLeadMoverPos[nIdx] := -1;
			FOR i:= 1 TO MAX_MOVER DO
			
				stMoverInfo := ipMover[i].GetMoverInfo();	
			
				IF stMoverInfo.bMoverStandstill 
					AND stMoverInfo.rModuloActPos < stVisuIO.fSetPos2 +1 		// +/- 1
					AND stMoverInfo.rModuloActPos >	stVisuIO.fSetPos2 -1 	// +/- 1
				THEN	
					xLeadMoverPos[nIdx] := TRUE;
					nLeadMoverPos[nIdx] := TO_INT(i);
					
					
				//	ipMover[nIdx].MoveToPosCa(FALSE, stMoveData_Clear);
					
					EXIT;
				END_IF		 	
			END_FOR

		// detect LeadMover at Pos3 (window +- 1)
			nIdx:= 3;
			xLeadMoverPos[nIdx] := FALSE;
			nLeadMoverPos[nIdx] := -1;
			FOR i:= 1 TO MAX_MOVER DO
			
				stMoverInfo := ipMover[i].GetMoverInfo();	
			
				IF stMoverInfo.bMoverStandstill 
					AND stMoverInfo.rModuloActPos < stVisuIO.fSetPos3 +1 		// +/- 1
					AND stMoverInfo.rModuloActPos >	stVisuIO.fSetPos3 -1 	// +/- 1
				THEN	
					xLeadMoverPos[nIdx] := TRUE;
					nLeadMoverPos[nIdx] := TO_INT(i);
					
					
				//	ipMover[nIdx].MoveToPosCa(FALSE, stMoveData_Clear);
					
					EXIT;
				END_IF		 	
			END_FOR

		// delayTime at Pos X
			FOR i:= 1 TO 3 DO
				fbWaitTimeAtPos[i](IN:= xLeadMoverPos[i], PT:= T#1.2S);
			END_FOR



		// Position 1 -------------------------------------------------
		// Start Lead Mover to Pos2
		nIdx :=nLeadMoverPos[1];
		
	

		// Position 2 -------------------------------------------------
		// Start Lead Mover to Pos3
		nIdx :=nLeadMoverPos[2];
	
		IF (nLeadMoverPos[2] > 0 AND nLeadMoverPos[2] <= TO_INT(MAX_MOVER))
		AND fbWaitTimeatPos[2].Q		
		AND xLeadMoverPos[2]																	// LeadMover found
		AND (	ipCaGroup.GroupInfo.GroupMoving 		// MC_GROUP_STATE.mcGroupStateMoving	// Ca-Group Moving
				OR ipCaGroup.GroupInfo.GroupStandby) 	// MC_GROUP_STATE.mcGroupStateStandby	// Ca-Group StandBy
		THEN
			stMoverInfo := ipMover[nIdx].GetMoverInfo();
			
			IF stMoverInfo.bMoverStandstill
				AND NOT stMoverInfo.bMoverAvoidingCollision	
			THEN			// Mover is not Busy	
	
				stMoveData.rPos := 			stVisuIO.fSetPos3;
				stMoveData.rVelo := 		1500;
				stMoveData.rAcc := 			Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rJerk := 		Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rGap := 			100; 
				stMoveData.rOverride := 	100;
				stMoveData.rDelta := 		1;
				stMoveData.rDistance := 	0;
			
				//Execute- Pos 2->3
				IF ipMover[nIdx].MoveToPosCa(FALSE, stMoveData) = E_PROGRESS.PROGRESS_INIT THEN
					ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);
				END_IF
				
				//ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);

			END_IF	
		END_IF	

		// Position 3 -------------------------------------------------
		// Start Lead Mover to Pos1
		nIdx :=nLeadMoverPos[3];	
	
		IF (nLeadMoverPos[3] > 0 AND nLeadMoverPos[3] <= TO_INT(MAX_MOVER))
		AND fbWaitTimeatPos[3].Q		
		AND xLeadMoverPos[3]																	// LeadMover found
		AND (	ipCaGroup.GroupInfo.GroupMoving 		// MC_GROUP_STATE.mcGroupStateMoving	// Ca-Group Moving
				OR ipCaGroup.GroupInfo.GroupStandby) 	// MC_GROUP_STATE.mcGroupStateStandby	// Ca-Group StandBy
		THEN
			stMoverInfo := ipMover[nIdx].GetMoverInfo();
			
			IF stMoverInfo.bMoverStandstill
				AND NOT stMoverInfo.bMoverAvoidingCollision	
			THEN			// Mover is not Busy	
	
				stMoveData.rPos := 			stVisuIO.fSetPos1;
				stMoveData.rVelo := 		3000;
				stMoveData.rAcc := 			Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rJerk := 		Tc3_Mc3Definitions.MC_DEFAULT;
				stMoveData.rGap := 			77; (*66*)
				stMoveData.rOverride := 	100;
				stMoveData.rDelta := 		1;
				stMoveData.rDistance := 	0;
				
				//Execute- Pos 3->1
				IF ipMover[nIdx].MoveToPosCa(FALSE, stMoveData) = E_PROGRESS.PROGRESS_INIT THEN
					ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);
				END_IF
				
				//ipMover[nIdx].MoveToPosCa(TRUE, stMoveData);

			END_IF
		END_IF	
		
		
		
		// Check standstill		
		xAllMoverStandStill := TRUE;
		FOR i:= 1 TO MAX_MOVER DO
			stMoverInfo := ipMover[i].GetMoverInfo();
			xAllMoverStandStill := 
				xAllMoverStandStill
				AND stMoverInfo.bMoverStandstill ;
		END_FOR
		
		IF NOT xLeadMoverPos[2]
			AND NOT xLeadMoverPos[3]	
			AND xAllMoverStandStill	
		THEN
			FOR i:= 1 TO MAX_MOVER DO
				
				ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			
			END_FOR
			_iState := 99;
		END_IF	


	
	
	99: // Internal
		_iState := 100; 
		_iSequencCount := _iSequencCount +1; 
			
	
	100: // Done
		_bBusy := FALSE;	
		

	END_CASE

	// ReturnValue
	M_Empty:= _bBusy;
	
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Home" Id="{58332f37-c644-4204-9d05-1d8ef6cb05f9}">
      <Declaration><![CDATA[METHOD M_Home : BOOL  // Busy
VAR_INPUT
	Execute		: BOOL;
END_VAR

VAR_INST
	_iState				: INT;
	_bBusy				: BOOL;
	_iSequencCount		: INT;
	                	
	                	
	_xLeadMoverFound 		: BOOL; 
	_xAllMoverStandStill	: BOOL;
END_VAR

VAR 
	i					: UINT;
	fAbsStartPos		: LREAL;
	                	
	xAllMoverActive 	: BOOL;
	fLeadMoverPos 		: LREAL;  
	xLeadMoverFound 	: BOOL; 
	xAllMoverStandStill	: BOOL;	
	

	stMoveData_Clear		: ST_MOVE_DATA;
	stMoveData				: ST_MOVE_DATA;
	
	stMoverInfo				: ST_MOVER_INFO;
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Starting Sequence
(*
	- Clear Command
	- Send all movers to start position
	- Look for a mover stopped in the start position
	- Start Conveyor (if available and necessary)
	- ...
*)


IF NOT Execute THEN
	M_Home := TRUE;
	_iState := 0;
	_bBusy := FALSE;
END_IF

	IF (_iState < 0)	
		OR (_iState > 100)	
		OR (_iState = 100 AND NOT _bBusy) 
		OR (not Execute )
	THEN
		_iState := 0;
		_bBusy := FALSE;
	END_IF

	
	CASE _iState OF
	0:	// idel
		
		IF NOT Execute THEN
			;
		ELSE
			_bBusy := TRUE;
			_iState := 10;
			_xLeadMoverFound :=FALSE; 
			_xAllMoverStandStill := FALSE;
		END_IF
	
	10:	// Clear Command	
		_bBusy := TRUE;
	
		stMoveData_Clear.rPos := 0;
		stMoveData_Clear.rVelo := 0;
		stMoveData_Clear.rAcc := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rJerk := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rGap := 100;
		stMoveData_Clear.rOverride := 100;
		stMoveData_Clear.rDelta := 0;
		stMoveData_Clear.rDistance := 0;
		
		//ClearCmd to Mover  -->   For Loop 	ipMover
		FOR i := 1 TO MAX_MOVER DO
			ipMover[i].Disable(FALSE);
			ipMover[i].Enable(FALSE);
			//ipMover[i].GearIn(FALSE,);
			//ipMover[i].GearInPosCa(FALSE,);
			ipMover[i].GearOut(FALSE);
			ipMover[i].Halt(FALSE, stMoveData_Clear);
			ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			ipMover[i].Reset(FALSE);
			ipMover[i].SendToPosCa(FALSE,stMoveData_Clear);
		END_FOR
		
		// ClearCmd to Ca-Group					ipCaGroup					
		ipCaGroup.AddAll(FALSE);
		ipCaGroup.Disable(FALSE);
		ipCaGroup.Enable(FALSE);
		ipCaGroup.McHaltAll(FALSE);
		ipCaGroup.McResetAll(FALSE);
		ipCaGroup.RemoveAll(FALSE);
		ipCaGroup.Reset(FALSE);

		stVisuIO.bAgain := TRUE;
		FOR i := 1 TO MAX_MOVER DO
			IF ipMover[i].MoveToPosCa(FALSE, stMoveData) = E_PROGRESS.PROGRESS_INIT THEN
				_iState := 20;
			END_IF	
		END_FOR
			
	20: //Send all movers to start position 

		(*
		## use ipMover[i].MoveModuloCa	
			// Calculate Absolute Position from Modulo will done in the Method MoveModuloCa			
		*); 
 		
	//	_stMoveParameter.fPosition := 			stVisuIO.fSetPos1;
	//	_stMoveParameter.fVelocity := 			500;
	//	_stMoveParameter.fAccel := 				MC_DEFAULT;
	//	_stMoveParameter.fDecel := 				MC_DEFAULT;
	//	_stMoveParameter.fJerk := 				MC_DEFAULT;
	//	_stMoveParameter.fGab := 				66;
	//	_stMoveParameter.ContinuousUpdate := 	TRUE;
	//	_stMoveParameter.eDirection := 			Tc2_MC2.MC_Positive_Direction;	
		
		stMoveData.rPos := 			stVisuIO.fSetPos1;
		stMoveData.rVelo := 		500;
		stMoveData.rAcc := 			Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData.rJerk := 		Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData.rGap := 			80; (* 66 *)
		stMoveData.rOverride := 	100;
		stMoveData.rDelta := 		5;
		stMoveData.rDistance := 	0;
		

		xLeadMoverFound := FALSE;
		xAllMoverStandStill := TRUE;	
	
		FOR i := 1 TO MAX_MOVER DO
			stMoverInfo:= ipMover[i].GetMoverInfo();
			
							
			CASE ipMover[i].MoveToPosCa(TRUE, stMoveData) OF
				E_PROGRESS.PROGRESS_DONE
				(*, E_PROGRESS.PROGRESS_PREPARE*) : 
				
						IF stMoverInfo.rModuloActPos > stMoverInfo.rModuloTargetPos -1
							AND stMoverInfo.rModuloActPos < stMoverInfo.rModuloTargetPos +1
						THEN
							xLeadMoverFound := TRUE;	
						END_IF
						
						xAllMoverStandStill := 
							xAllMoverStandStill
							AND stMoverInfo.bMoverStandstill;
						
				E_PROGRESS.PROGRESS_WORKING:
				
						 xAllMoverStandStill:= 
							xAllMoverStandStill
							AND stMoverInfo.bMoverStandstill;		

			END_CASE
		
		END_FOR

		_xLeadMoverFound 		:= xLeadMoverFound ;    
		_xAllMoverStandStill	:= xAllMoverStandStill ;	

		
		IF xLeadMoverFound 
		AND xAllMoverStandStill	THEN
			FOR i:= 1 TO MAX_MOVER DO
				ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear) ;			// Clear MoveToPos Cmd
			END_FOR
			
			_iState := 99;
		END_IF		
		

	
 	40:	// Clear MoveVelocity Conveyor --> if available and necessary
		;	
			

	50: // tell conveyor to mover 	--> if available and necessary
		;

	99:	// Internal
		_iState := 100;
		_iSequencCount := _iSequencCount +1;
				
	100: // Done
		_bBusy := FALSE;	
		

	
	END_CASE

	// ReturnValue
	M_Home := _bBusy;
	
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Prepare" Id="{5ac4a7cf-34dd-4b05-ab48-50d6fc125d33}">
      <Declaration><![CDATA[METHOD M_Prepare : BOOL  // Busy
VAR_INPUT
	Execute		: BOOL;
END_VAR

VAR_INST
	_iState			: INT;
	_bBusy			: BOOL;
	_iSequencCount	: INT;
END_VAR

VAR 
	i					: UINT;
	xAllAxisReset		: BOOL;
	xAllAxisInGroup		: BOOL;
	xAllMoversEnabled	: BOOL;
	

	stInAddMoverToGroup	: INT;
	
	stMoveData_Clear	: ST_MOVE_DATA;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Clearing Sequence
(*
	-! Clear Command
	- ...
	- Add All movers to the CA-Group 
	- Reset Axis
	- Enable Axis
	- Enable CA-Group
	- ...

*)

IF NOT Execute THEN
	M_Prepare := TRUE;
	_iState := 0;
	_bBusy := FALSE;
	
	RETURN;
END_IF

	IF (_iState < 0)	
		OR (_iState > 100)	
		OR (_iState = 100 AND NOT _bBusy) 
		OR (NOT Execute)
	THEN
		_iState := 0;
		_bBusy := FALSE;
	END_IF

	
	CASE _iState OF
	0:	// idel
		
		IF NOT Execute THEN
			;
		ELSE
			_bBusy := TRUE;
			_iState := 10;
		END_IF
	
	10:	// Clear Command	
		_bBusy := TRUE;
	
		stMoveData_Clear.rPos := 0;
		stMoveData_Clear.rVelo := 0;
		stMoveData_Clear.rAcc := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rJerk := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rGap := 100;
		stMoveData_Clear.rOverride := 100;
		stMoveData_Clear.rDelta := 0;
		stMoveData_Clear.rDistance := 0;
		
		//ClearCmd to Mover  -->   For Loop 	ipMover
		FOR i := 1 TO MAX_MOVER DO
			ipMover[i].Disable(FALSE);
			ipMover[i].Enable(FALSE);
			//ipMover[i].GearIn(FALSE,);
			//ipMover[i].GearInPosCa(FALSE,);
			ipMover[i].GearOut(FALSE);
			ipMover[i].Halt(FALSE, stMoveData_Clear);
			ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			ipMover[i].Reset(FALSE);
			ipMover[i].SendToPosCa(FALSE,stMoveData_Clear);
		END_FOR
		
		// ClearCmd to Ca-Group					ipCaGroup					
		ipCaGroup.AddAll(FALSE);
		ipCaGroup.Disable(FALSE);
		ipCaGroup.Enable(FALSE);
		ipCaGroup.McHaltAll(FALSE);
		ipCaGroup.McResetAll(FALSE);
		ipCaGroup.RemoveAll(FALSE);
		ipCaGroup.Reset(FALSE);		
		
		_iState := 30;

		
	30: // Check to see that no Axis are in the group, adding axis a second time will create a fault 	
	
		(*
		## check with ipCaGroup.P_CountAxisInGroup 
		## use ipCaGroup.UngroupAllAxes()					
		*); 
		
		IF ipCaGroup.GroupInfo.AxisCount <> 0 THEN
			
			// Ungroup All Movers
			CASE ipCaGroup.RemoveAll(TRUE) OF	
			E_PROGRESS.PROGRESS_ERROR :
					; // Error Handler	
			
			E_PROGRESS.PROGRESS_BUSY : 
					;
					
			E_PROGRESS.PROGRESS_DONE :
				ipCaGroup.RemoveAll(FALSE);
				_iState := 40;
				ipCaGroup.AddAll(FALSE);
			
			END_CASE
				
		ELSE 
			_iState := 40;
		END_IF 	

		
	40: // Add All movers to the collision avoidance group 
		
		(*
		## use 	ipMover[i].AddAxistoGroup(...
		## check with ipMover[i].AddAxistoGroup  		or 
		## check with ipCaGroup.P_CountAxisInGroup				
		*); 
	
		CASE  ipCaGroup.AddAll(TRUE) OF 
		E_PROGRESS.PROGRESS_DONE :
				ipCaGroup.AddAll(FALSE);
			_iState := 50;
			FOR i:= 1 TO MAX_MOVER DO
				ipMover[i].Reset(FALSE);
			END_FOR
		
		END_CASE

		
	50: // Reset Axis	
		xAllAxisReset:= TRUE;
		FOR i:= 1 TO MAX_MOVER DO
			xAllAxisReset :=
				xAllAxisReset 
				AND ipMover[i].Reset(TRUE) = E_PROGRESS.PROGRESS_DONE;
				
		END_FOR
		
		IF xAllAxisReset THEN
			_iState := 60;
			FOR i:= 1 TO MAX_MOVER DO
				ipMover[i].Enable(FALSE);
			END_FOR	
		END_IF		
		
	60: // Enable Axis in place 		
		
		(*
		## use ipMover[i].PowerOn(Override)
		## check with ipMover[i].P_AxisStatus.ControlLoopClosed		
		*); 
		
		xAllMoversEnabled := TRUE;
		FOR i:= 1 TO MAX_MOVER DO
			xAllMoversEnabled:= 
				xAllMoversEnabled
				AND ipMover[i].Enable(TRUE) = E_PROGRESS.PROGRESS_DONE;
	
		END_FOR
		
		IF xAllMoversEnabled THEN
			_iState := 70;
		END_IF

		
		
	70: //If the group is disabled, enable it 
	
		(*
		## check with ipCaGroup.P_CaGroupState & MC_GROUP_STATE
		## use ipCaGroup.CaGroupReset()
		## use ipCaGroup.EnableGroup() 
		*);
		
		IF ipCaGroup.GroupInfo.GroupErrorStop = TRUE (*MC_GROUP_STATE.mcGroupStateErrorStop*) THEN		// GroupErrorStop
			_iState := _iState +1;
			
		ELSIF ipCaGroup.GroupInfo.GroupDisabled = TRUE (*MC_GROUP_STATE.mcGroupStateDisabled*) THEN	// GroupDisabled
			_iState := _iState +2;

		ELSIF ipCaGroup.GroupInfo.GroupStandby = TRUE (*MC_GROUP_STATE.mcGroupStateStandby*) THEN	// GroupStandby
			
			_iState := 99;	
		END_IF
		
	71:	// Reset CA-Group
		IF ipCaGroup.Reset(TRUE) = E_PROGRESS.PROGRESS_DONE THEN
			ipCaGroup.Reset(FALSE);
			_iState := 70;
		END_IF
			
	72:	// Enable CA-Group
		IF ipCaGroup.Enable(TRUE) = E_PROGRESS.PROGRESS_DONE THEN
			ipCaGroup.Enable(FALSE);
			_iState := 70;
		END_IF					
		
		
		

	99:	// Internal
		_iState := 100;
		_iSequencCount := _iSequencCount +1;
		
	100: // Done
		_bBusy := FALSE;	
		

	
	END_CASE

	// ReturnValue
	M_Prepare:= _bBusy;
	
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Reset" Id="{47d01e48-bf5a-4148-95b1-eff6c3781e7e}">
      <Declaration><![CDATA[METHOD M_Reset : BOOL  // Busy
VAR_INPUT
	Execute					: BOOL;
END_VAR

VAR_INST
	_iState					: INT;
	_bBusy					: BOOL;
	_iSequencCount			: INT;
                    		
	fbWaitTime				: TON;

END_VAR

VAR 
	i						: UINT;
	xHaltCaDone				: BOOL;
	xAllMoversDisabled		: BOOL;

	xAllAxisReset			: BOOL;
	
	stMoveData_Clear		: ST_MOVE_DATA;
	stMoverInfo				: ST_MOVER_INFO;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Reset Sequence
(*
	- Clear Command
	- Reset Ca-Group
	- Reset Mover
*)

IF NOT Execute THEN
	M_Reset := TRUE;
	_iState := 0;
	_bBusy := FALSE;
	
	RETURN;
END_IF

	IF (_iState < 0)	
		OR (_iState > 100)	
		OR (_iState = 100 AND NOT _bBusy) 
		OR (NOT Execute)
	THEN
		_iState := 0;
		_bBusy := FALSE;
	END_IF

	
	CASE _iState OF
	0:	// idel
		
		IF NOT Execute THEN
			;
		ELSE
			_bBusy := TRUE;
			_iState := 10;
		END_IF
	
	10:	// Clear Command	
		_bBusy := TRUE;
	
		stMoveData_Clear.rPos := 0;
		stMoveData_Clear.rVelo := 0;
		stMoveData_Clear.rAcc := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rJerk := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rGap := 100;
		stMoveData_Clear.rOverride := 100;
		stMoveData_Clear.rDelta := 0;
		stMoveData_Clear.rDistance := 0;
		
		//ClearCmd to Mover  -->   For Loop 	ipMover
		FOR i := 1 TO MAX_MOVER DO
			ipMover[i].Disable(FALSE);
			ipMover[i].Enable(FALSE);
			//ipMover[i].GearIn(FALSE,);
			//ipMover[i].GearInPosCa(FALSE,);
			ipMover[i].GearOut(FALSE);
			ipMover[i].Halt(FALSE, stMoveData_Clear);
			ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			ipMover[i].Reset(FALSE);
			ipMover[i].SendToPosCa(FALSE,stMoveData_Clear);
		END_FOR
		
		// ClearCmd to Ca-Group					ipCaGroup					
		ipCaGroup.AddAll(FALSE);
		ipCaGroup.Disable(FALSE);
		ipCaGroup.Enable(FALSE);
		ipCaGroup.McHaltAll(FALSE);
		ipCaGroup.McResetAll(FALSE);
		ipCaGroup.RemoveAll(FALSE);
		ipCaGroup.Reset(FALSE);


		
		
		_iState := 20;
	
		
//	20: // to do !!!!
//	
//		fbWaitTime(IN:= TRUE, PT:= T#1S, Q=> , ET=> );
//	
//		IF fbWaitTime.Q THEN	
//			iState := 99; 
//			fbWaitTime(IN:= FALSE);
//
//		END_IF


	20:	// Error CA-Group
		IF ipCaGroup.GroupInfo.GroupError
			OR ipCaGroup.GroupInfo.GroupErrorStop 
		THEN
			IF ipCaGroup.Reset(TRUE) = E_PROGRESS.PROGRESS_DONE
				AND NOT ipCaGroup.GroupInfo.GroupError
				AND NOT ipCaGroup.GroupInfo.GroupErrorStop 
			THEN
				ipCaGroup.Reset(FALSE);
				_iState := 30; 	
			END_IF
		ELSE 
			_iState := 30; 	
		END_IF

		
	30: // Error Mover
		xAllAxisReset := TRUE;
		FOR i:= 1 TO MAX_MOVER DO
			stMoverInfo := ipMover[i].GetMoverInfo(); 
			IF stMoverInfo.bMoverError THEN
				ipMover[i].Reset(TRUE);
			END_IF
	
			xAllAxisReset := 
					xAllAxisReset
					AND NOT stMoverInfo.bMoverError;
		
		END_FOR
	
		IF xAllAxisReset THEN
			_iState := 40;
		END_IF
	

	40: // Wait 
	
		fbWaitTime(IN:= TRUE, PT:= T#1S, Q=> , ET=> );
	
		IF fbWaitTime.Q THEN	
			_iState := 99; 
			fbWaitTime(IN:= FALSE);

		END_IF


	
	99: // Internal
		_iState := 100; 
		_iSequencCount := _iSequencCount +1; 
			
	
	100: // Done
		_bBusy := FALSE;	
					

	
	END_CASE

	// ReturnValue
	M_Reset:= _bBusy;
	
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Stopping" Id="{11d4c136-7027-4b1d-8be8-305f5728ad58}">
      <Declaration><![CDATA[METHOD M_Stopping : BOOL  // Busy
VAR_INPUT
	Execute		: BOOL;
END_VAR

VAR_INST
	_iState			: INT;
	_bBusy			: BOOL;
	_iSequencCount	: INT;
END_VAR

VAR 
	i					: UINT;
	
	xAllMoverStandStill	: BOOL;
	xHaltDone			: BOOL;
	
	stMoveData_Clear	: ST_MOVE_DATA;
	stMoveData			: ST_MOVE_DATA;
	
	stMoverInfo			: ST_MOVER_INFO;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Stoping Sequence
(*
	- Clear Command
	- Stop Mover

*)

IF NOT Execute THEN
	M_Stopping := TRUE;
	_iState := 0;
	_bBusy := FALSE;
	
	RETURN;
END_IF

	IF (_iState < 0)	
		OR (_iState > 100)	
		OR (_iState = 100 AND NOT _bBusy) 
		OR (NOT Execute)
	THEN
		_iState := 0;
		_bBusy := FALSE;
	END_IF

	
	CASE _iState OF
	0:	// idel
		
		IF NOT Execute THEN
			;
		ELSE
			_bBusy := TRUE;
			_iState := 10;
		END_IF
	
	10:	// Clear Command	
		_bBusy := TRUE;
	
		stMoveData_Clear.rPos := 0;
		stMoveData_Clear.rVelo := 0;
		stMoveData_Clear.rAcc := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rJerk := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData_Clear.rGap := 100;
		stMoveData_Clear.rOverride := 100;
		stMoveData_Clear.rDelta := 0;
		stMoveData_Clear.rDistance := 0;
		
		//ClearCmd to Mover  -->   For Loop 	ipMover
		FOR i := 1 TO MAX_MOVER DO
			ipMover[i].Disable(FALSE);
			ipMover[i].Enable(FALSE);
			//ipMover[i].GearIn(FALSE,);
			//ipMover[i].GearInPosCa(FALSE,);
			ipMover[i].GearOut(FALSE);
			ipMover[i].Halt(FALSE, stMoveData_Clear);
			ipMover[i].MoveToPosCa(FALSE, stMoveData_Clear);
			ipMover[i].Reset(FALSE);
			ipMover[i].SendToPosCa(FALSE,stMoveData_Clear);
		END_FOR
		
		// ClearCmd to Ca-Group					ipCaGroup					
		ipCaGroup.AddAll(FALSE);
		ipCaGroup.Disable(FALSE);
		ipCaGroup.Enable(FALSE);
		ipCaGroup.McHaltAll(FALSE);
		ipCaGroup.McResetAll(FALSE);
		ipCaGroup.RemoveAll(FALSE);
		ipCaGroup.Reset(FALSE);
	
		_iState := 20;
	

	20:	// HaltCmd to Mover 
	
		stMoveData.rPos := 0;
		stMoveData.rVelo := 0;
		stMoveData.rAcc := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData.rJerk := Tc3_Mc3Definitions.MC_DEFAULT;
		stMoveData.rGap := 75;
		stMoveData.rOverride := 100;
		stMoveData.rDelta := 0;
		stMoveData.rDistance := 0;
	
		xAllMoverStandStill := TRUE;
		FOR i := 1 TO MAX_MOVER DO
			stMoverInfo:= ipMover[i].GetMoverInfo();	
		
			CASE ipMover[i].Halt(TRUE, stMoveData) OF
				E_PROGRESS.PROGRESS_DONE :
						xAllMoverStandStill := 
							xAllMoverStandStill
							AND stMoverInfo.bMoverStandstill;
							
			ELSE
				xAllMoverStandStill:= FALSE;				
			END_CASE
		END_FOR
	
		IF xAllMoverStandStill THEN
			FOR i := 1 TO MAX_MOVER DO
				ipMover[i].Halt(FALSE, stMoveData);
			END_FOR
			
			_iState := _iState +1 ;
		END_IF
		
			
	21:	// HaldCmd Done	
		
			
			_iState := 99;
			
		
	

	99:	// Internal
		_iState := 100;
		_iSequencCount := _iSequencCount +1;
		
	100: // Done
		_bBusy := FALSE;	
		
	
		
	

	
	END_CASE

	// ReturnValue
	M_Stopping:= _bBusy;
	
	]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_SimpleCaExample">
      <LineId Id="10" Count="3" />
      <LineId Id="523" Count="0" />
      <LineId Id="14" Count="4" />
      <LineId Id="481" Count="0" />
      <LineId Id="478" Count="0" />
      <LineId Id="476" Count="0" />
      <LineId Id="401" Count="1" />
      <LineId Id="477" Count="0" />
      <LineId Id="480" Count="0" />
      <LineId Id="420" Count="0" />
      <LineId Id="422" Count="3" />
      <LineId Id="403" Count="0" />
      <LineId Id="429" Count="0" />
      <LineId Id="404" Count="0" />
      <LineId Id="430" Count="0" />
      <LineId Id="483" Count="6" />
      <LineId Id="482" Count="0" />
      <LineId Id="432" Count="0" />
      <LineId Id="431" Count="0" />
      <LineId Id="427" Count="1" />
      <LineId Id="490" Count="0" />
      <LineId Id="496" Count="0" />
      <LineId Id="491" Count="4" />
      <LineId Id="405" Count="0" />
      <LineId Id="436" Count="0" />
      <LineId Id="441" Count="3" />
      <LineId Id="497" Count="0" />
      <LineId Id="504" Count="0" />
      <LineId Id="500" Count="3" />
      <LineId Id="435" Count="0" />
      <LineId Id="440" Count="0" />
      <LineId Id="445" Count="3" />
      <LineId Id="505" Count="0" />
      <LineId Id="512" Count="0" />
      <LineId Id="507" Count="0" />
      <LineId Id="509" Count="2" />
      <LineId Id="449" Count="0" />
      <LineId Id="437" Count="0" />
      <LineId Id="450" Count="3" />
      <LineId Id="513" Count="0" />
      <LineId Id="520" Count="0" />
      <LineId Id="455" Count="17" />
      <LineId Id="438" Count="1" />
      <LineId Id="434" Count="0" />
      <LineId Id="406" Count="0" />
      <LineId Id="433" Count="0" />
      <LineId Id="407" Count="2" />
      <LineId Id="411" Count="8" />
      <LineId Id="400" Count="0" />
      <LineId Id="19" Count="5" />
      <LineId Id="260" Count="0" />
      <LineId Id="295" Count="0" />
      <LineId Id="261" Count="1" />
      <LineId Id="183" Count="0" />
      <LineId Id="25" Count="7" />
      <LineId Id="399" Count="0" />
      <LineId Id="383" Count="0" />
      <LineId Id="385" Count="3" />
      <LineId Id="394" Count="0" />
      <LineId Id="398" Count="0" />
      <LineId Id="396" Count="1" />
      <LineId Id="378" Count="0" />
      <LineId Id="33" Count="5" />
      <LineId Id="186" Count="0" />
      <LineId Id="297" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="265" Count="1" />
      <LineId Id="263" Count="0" />
      <LineId Id="298" Count="0" />
      <LineId Id="264" Count="0" />
      <LineId Id="40" Count="1" />
      <LineId Id="239" Count="0" />
      <LineId Id="299" Count="0" />
      <LineId Id="240" Count="1" />
      <LineId Id="187" Count="0" />
      <LineId Id="42" Count="14" />
      <LineId Id="188" Count="0" />
      <LineId Id="300" Count="0" />
      <LineId Id="267" Count="3" />
      <LineId Id="242" Count="0" />
      <LineId Id="301" Count="0" />
      <LineId Id="243" Count="1" />
      <LineId Id="57" Count="12" />
      <LineId Id="189" Count="0" />
      <LineId Id="302" Count="0" />
      <LineId Id="271" Count="3" />
      <LineId Id="245" Count="0" />
      <LineId Id="303" Count="0" />
      <LineId Id="246" Count="1" />
      <LineId Id="70" Count="12" />
      <LineId Id="190" Count="0" />
      <LineId Id="304" Count="0" />
      <LineId Id="275" Count="3" />
      <LineId Id="226" Count="0" />
      <LineId Id="305" Count="0" />
      <LineId Id="229" Count="0" />
      <LineId Id="227" Count="1" />
      <LineId Id="224" Count="0" />
      <LineId Id="306" Count="0" />
      <LineId Id="225" Count="0" />
      <LineId Id="233" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="232" Count="0" />
      <LineId Id="84" Count="6" />
      <LineId Id="279" Count="0" />
      <LineId Id="307" Count="0" />
      <LineId Id="280" Count="2" />
      <LineId Id="191" Count="0" />
      <LineId Id="308" Count="0" />
      <LineId Id="91" Count="2" />
      <LineId Id="192" Count="0" />
      <LineId Id="309" Count="0" />
      <LineId Id="94" Count="2" />
      <LineId Id="248" Count="0" />
      <LineId Id="310" Count="0" />
      <LineId Id="249" Count="1" />
      <LineId Id="193" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="370" Count="1" />
      <LineId Id="100" Count="9" />
      <LineId Id="283" Count="0" />
      <LineId Id="311" Count="0" />
      <LineId Id="284" Count="2" />
      <LineId Id="194" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="110" Count="2" />
      <LineId Id="251" Count="0" />
      <LineId Id="313" Count="0" />
      <LineId Id="252" Count="1" />
      <LineId Id="195" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="372" Count="1" />
      <LineId Id="114" Count="0" />
      <LineId Id="116" Count="5" />
      <LineId Id="287" Count="0" />
      <LineId Id="314" Count="0" />
      <LineId Id="288" Count="2" />
      <LineId Id="196" Count="0" />
      <LineId Id="315" Count="0" />
      <LineId Id="122" Count="2" />
      <LineId Id="254" Count="0" />
      <LineId Id="316" Count="0" />
      <LineId Id="255" Count="1" />
      <LineId Id="197" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="374" Count="1" />
      <LineId Id="126" Count="0" />
      <LineId Id="128" Count="3" />
      <LineId Id="291" Count="0" />
      <LineId Id="318" Count="0" />
      <LineId Id="292" Count="2" />
      <LineId Id="198" Count="0" />
      <LineId Id="319" Count="0" />
      <LineId Id="132" Count="2" />
      <LineId Id="199" Count="0" />
      <LineId Id="320" Count="0" />
      <LineId Id="135" Count="2" />
      <LineId Id="257" Count="0" />
      <LineId Id="321" Count="0" />
      <LineId Id="258" Count="1" />
      <LineId Id="200" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="376" Count="1" />
      <LineId Id="139" Count="0" />
      <LineId Id="141" Count="2" />
      <LineId Id="201" Count="0" />
      <LineId Id="323" Count="1" />
      <LineId Id="326" Count="1" />
      <LineId Id="325" Count="0" />
      <LineId Id="144" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_SimpleCaExample.M_Active">
      <LineId Id="1415" Count="318" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SimpleCaExample.M_Clear">
      <LineId Id="1252" Count="244" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SimpleCaExample.M_Empty">
      <LineId Id="1258" Count="274" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SimpleCaExample.M_Home">
      <LineId Id="1407" Count="13" />
      <LineId Id="1422" Count="136" />
      <LineId Id="1606" Count="20" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SimpleCaExample.M_Prepare">
      <LineId Id="955" Count="209" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SimpleCaExample.M_Reset">
      <LineId Id="945" Count="3" />
      <LineId Id="952" Count="143" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SimpleCaExample.M_Stopping">
      <LineId Id="750" Count="131" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>